

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>apart.core.node &mdash; APART  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="APART  documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../contents.html" class="icon icon-home"> APART
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">APART</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../packages.html">Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../contents.html">APART</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../contents.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>apart.core.node</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for apart.core.node</h1><div class="highlight"><pre>
<span></span><span class="c1"># Author: Antoine Guellier</span>
<span class="c1"># Copyright (c) 2017 Université de Rennes 1</span>
<span class="c1"># License: CeCILL. The full license text is available at:</span>
<span class="c1">#  - http://www.cecill.info/licences/Licence_CeCILL_V2.1-fr.html</span>




<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the code of a network node. </span>

<span class="sd">The :class:`~apart.core.node.Node` class that it defines represents the core of</span>
<span class="sd">the protocol implementation. It models all the behavior of the nodes (mainly</span>
<span class="sd">message sending and receiving).</span>

<span class="sd">Most of the code is however defined in protected or private functions. These are</span>
<span class="sd">also documented (but not included in this documentation by default). See the</span>
<span class="sd">source code of class :class:`.Node` for more information.</span>

<span class="sd">This module also defines the :exc:`.ProtocolError` exception.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">_collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">apart.core.controlled_traffic_rates</span> <span class="k">import</span> <span class="n">TrafficController</span>
<span class="kn">from</span> <span class="nn">apart.core.messages</span> <span class="k">import</span> <span class="n">MsgFlag</span><span class="p">,</span> <span class="n">LinkMsg</span><span class="p">,</span> <span class="n">MsgInnerFlag</span><span class="p">,</span>\
    <span class="n">MsgInnerHeader</span><span class="p">,</span> <span class="n">EndToEndDummyError</span>
<span class="kn">from</span> <span class="nn">apart.core.pools</span> <span class="k">import</span> <span class="n">NeighborMsgPoolSet</span>
<span class="kn">from</span> <span class="nn">apart.core.protocol_constants</span> <span class="k">import</span> <span class="n">GROUP_G</span><span class="p">,</span> <span class="n">F_NULL</span><span class="p">,</span> <span class="n">GROUP_P</span><span class="p">,</span>\
    <span class="n">RtPolicyReason</span>
<span class="kn">from</span> <span class="nn">apart.core.tables</span> <span class="k">import</span> <span class="n">RoutingTable</span> <span class="k">as</span> <span class="n">RT</span><span class="p">,</span> <span class="n">PrevRoutingTable</span> <span class="k">as</span> <span class="n">PRT</span>
<span class="kn">from</span> <span class="nn">common.utilities</span> <span class="k">import</span> <span class="n">pprinttable</span><span class="p">,</span> <span class="n">range1</span>
<span class="kn">from</span> <span class="nn">apart.crypto</span> <span class="k">import</span> <span class="n">Elgamal_keygen</span><span class="p">,</span> <span class="n">Elgamal_enc</span><span class="p">,</span> <span class="n">Reenc_nopk</span><span class="p">,</span> \
    <span class="n">Elgamal_scalar_exp</span><span class="p">,</span> <span class="n">Elgamal_enc_nopk</span><span class="p">,</span> <span class="n">Elgamal_ctxt_div</span><span class="p">,</span> \
    <span class="n">Elgamal_accumulator_check</span><span class="p">,</span> <span class="n">Elgamal_key_div</span><span class="p">,</span> <span class="n">Elgamal_plain_mult</span><span class="p">,</span> <span class="n">SHA3_hash</span><span class="p">,</span> \
    <span class="n">Elgamal_dec</span><span class="p">,</span> <span class="n">Reenc_one</span><span class="p">,</span> <span class="n">Elgamal_key_mult</span><span class="p">,</span> <span class="n">Elgamal_accumulator_add</span><span class="p">,</span> \
    <span class="n">DecryptionError</span><span class="p">,</span> <span class="n">group_inverse</span><span class="p">,</span> <span class="n">Reenc_pk</span>


<div class="viewcode-block" id="Node"><a class="viewcode-back" href="../../../apart.core.node.html#apart.core.node.Node">[docs]</a><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">net_manager</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This class models a node in the network. </span>
<span class="sd">    </span>
<span class="sd">        It builds and manages the internal state of the node. The main function :meth:`.run()`</span>
<span class="sd">        is a SimPy process, and consist in an infinite loop where a message performs</span>
<span class="sd">        routing information and exchange messages with other nodes in the simulation</span>
<span class="sd">    </span>
<span class="sd">        The constructor builds the internal state of the node, and register the</span>
<span class="sd">        :meth:`run` method as a  SimPy process. In particular, the constructor</span>
<span class="sd">        builds all routing tables, initializes the node&#39;s src and dst values,</span>
<span class="sd">        its message spools and traffic rates counters</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            env (:obj:`simpy.core.Environment`): the SimPy environment</span>
<span class="sd">            net (:obj:`~apart.core.network.Network`): the Network class instance which contains the node</span>
<span class="sd">            net_manager (:obj:`~apart.core.network.NetworManager`): the network manaer instance</span>
<span class="sd">            node_id (int): the node&#39;s identity (an integer)</span>
<span class="sd">            neighbors (int list): list of neighbors nodes in the topology graph   </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># &quot;Global&quot; variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="sd">&quot;&quot;&quot;The SimPy environment of the simulation&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net</span> <span class="o">=</span> <span class="n">net</span>
        <span class="sd">&quot;&quot;&quot;The network the node belongs to&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span> <span class="o">=</span> <span class="n">net_manager</span>
        <span class="sd">&quot;&quot;&quot;The network manager instance, that coordinates the nodes&quot;&quot;&quot;</span>

        <span class="c1"># Initialize node information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="n">node_id</span>
        <span class="sd">&quot;&quot;&quot;The node&#39;s identity&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_src</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The node&#39;s secret src value (should be random, is simplified here)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dst</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The node&#39;s secret dst value (should be random, is simplified here)&quot;&quot;&quot;</span>
        
        <span class="c1"># Initialize the neighbors and their keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span> <span class="o">=</span> <span class="n">neighbors</span>
        <span class="sd">&quot;&quot;&quot;The list of node&#39;s neighbors in the topology graph&quot;&quot;&quot;</span>
        
        <span class="c1"># By default, a node is not corrupted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_corrupted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;The corruption state of a node. Every node is honest by default, and :meth:`.set_corruption_state` can be called to modify that&quot;&quot;&quot;</span>    
            
        <span class="c1"># Generate the node&#39;s keys</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">)</span> <span class="o">=</span> <span class="n">Elgamal_keygen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">secparam</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The long_term key pair of the node&quot;&quot;&quot;</span>
        
        <span class="c1"># Create routing tables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rt</span> <span class="o">=</span> <span class="n">RT</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">network_uid</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The node&#39;s main routing table&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prt</span> <span class="o">=</span> <span class="n">PRT</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">network_uid</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The node&#39;s &quot;previous hop&quot; routing table, to store multiple previous hop for each RT entry&quot;&quot;&quot;</span>
        
        <span class="c1"># Initialise the round counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batching_round</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The current batching round&quot;&quot;&quot;</span>

        
        <span class="c1"># Initialise the neighbor pools (for message re-ordering)</span>
        <span class="n">n_min</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">batching_nmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">batching_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_msg_pools</span> <span class="o">=</span> <span class="n">NeighborMsgPoolSet</span><span class="p">(</span><span class="n">n_min</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The node&#39;s pools of messages, one for each neighbor&quot;&quot;&quot;</span>
 
        <span class="c1"># Initialize the inbox of the node as a simple set and a counter. The</span>
        <span class="c1"># set is meant to contain only *real* mesasges,  while the counter gives</span>
        <span class="c1"># the number of received dummy messages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_real_msgs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;The node&#39;s incoming message box&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nb_incoming_dummy_msgs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The node&#39;s counter for receiver dummy messages&quot;&quot;&quot;</span>
        
        <span class="c1"># Initialise an instance of traffic controller</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span> <span class="o">=</span> <span class="n">TrafficController</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dummypol_deltar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The counters for the controller traffic rate mechanism&quot;&quot;&quot;</span>
        
        <span class="c1"># The node needs a structure to store its pending route proposals (the</span>
        <span class="c1"># one it sends, and the one it receives). Those are indexed by the cid</span>
        <span class="c1"># they are related to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rcvd&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;sent&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;to_relay&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;to_answer&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;to_repropose&#39;</span><span class="p">:</span> <span class="p">{}}</span>
        <span class="sd">&quot;&quot;&quot;Information on pending route proposals, either as proposer, proposee, receiver or relay&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sender&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;helper&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;to_receive&#39;</span><span class="p">:</span> <span class="p">{}}</span>
        <span class="sd">&quot;&quot;&quot;Information on ongoing oriented communications, as a sender or helper&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_must_self_propose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&quot;&quot;&quot;By default, when a node is created, it should self-propose as its first action (when its process is started, see :meth:`.run`)&quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_is_idle</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;Indicates whether the node is &quot;finished&quot;, w.r.t. the simualtion&quot;&quot;&quot;</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: The node&#39;s identity (an integer)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list of int: The node&#39;s neighbor in the topology graph&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: The node&#39;s long-term public key&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pk</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:obj:`~core.tables.RoutingTables`: The node&#39;s routing table&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rt</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:obj:`~core.tables.PrevRoutingTable`: The node&#39;s previous hop routing table&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">batching_round</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: The current batching round the node is in&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batching_round</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_idle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;bool: Becomes ``True`` when a node does not receive not send messages in a round.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_is_idle</span>
    
<div class="viewcode-block" id="Node.set_corruption_state"><a class="viewcode-back" href="../../../apart.core.node.html#apart.core.node.Node.set_corruption_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_corruption_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corrupted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the corruption state of the node&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_corrupted</span> <span class="o">=</span> <span class="n">corrupted</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_corrupted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;bool: True is the node is corrupted&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_corrupted</span>
    
        
        

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> (src = </span><span class="si">{}</span><span class="s2">, dst = </span><span class="si">{}</span><span class="s2">, msgs in pools = </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_msg_pools</span><span class="o">.</span><span class="n">n_real</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Functions governing the node process</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
<div class="viewcode-block" id="Node.run"><a class="viewcode-back" href="../../../apart.core.node.html#apart.core.node.Node.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The node&#39;s SimPy process, and main function.</span>
<span class="sd">        </span>
<span class="sd">        The node SimPy process basically consists in an infinite loop (as long</span>
<span class="sd">        the attribute :attr:`~apart.core.network.NetworkManager.is_running` of</span>
<span class="sd">        :attr:`_net_manager` is ``True``) that makes batching round pass. That</span>
<span class="sd">        is, the loop begins with a SimPy timeout event of the duration of the</span>
<span class="sd">        batching time interval; then looks at incoming messages, and finally</span>
<span class="sd">        sends messages according to the batching strategy and the controlled</span>
<span class="sd">        traffic rate mechanism.</span>
<span class="sd">        </span>
<span class="sd">        This function does not make the difference between the topology</span>
<span class="sd">        dissemination phase, and the oriented communication phase. It is just</span>
<span class="sd">        the core running function.</span>
<span class="sd">        </span>
<span class="sd">        Yields:</span>
<span class="sd">            :obj:`simpy.events.Timeout`: simpy timeout events, one for each batching round (SimPy advances in the simulation by advancing in generators). </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_must_self_propose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_must_self_propose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Initialization of the node&#39;s routing tables (i.e. insert the node</span>
            <span class="c1"># itself in its routing table)</span>
            <span class="n">self_pseudo</span> <span class="o">=</span> <span class="n">SHA3_hash</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src</span><span class="p">,</span> <span class="n">GROUP_P</span><span class="p">))</span>
            <span class="n">cone</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pk</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">cprop</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dst</span><span class="p">)</span>
            <span class="n">chopcount</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pk</span><span class="p">,</span> <span class="n">GROUP_G</span><span class="p">)</span>
            <span class="n">cwhoisontheroute</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pk</span><span class="p">,</span> <span class="s2">&quot; </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
            <span class="n">self_rt_entry</span> <span class="o">=</span> <span class="p">{</span><span class="n">RT</span><span class="o">.</span><span class="n">PSEUDO</span><span class="p">:</span> <span class="n">self_pseudo</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">:</span> <span class="n">F_NULL</span><span class="p">,</span>  <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">:</span> <span class="n">F_NULL</span><span class="p">,</span>  <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">:</span>  <span class="n">F_NULL</span><span class="p">,</span> 
                             <span class="n">RT</span><span class="o">.</span><span class="n">TIMESTAMP</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">REPROPOSED</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">IN_USE</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> 
                             <span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_LENGTH</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
            
            <span class="n">self_rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">insert_entry</span><span class="p">(</span><span class="o">**</span><span class="n">self_rt_entry</span><span class="p">)</span>
    
            <span class="c1"># The first action(s) that the node perform is a self-proposal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propose_route</span><span class="p">(</span><span class="n">self_rt_entry</span><span class="p">,</span> <span class="n">cprop</span><span class="p">,</span> <span class="n">cone</span><span class="p">,</span> <span class="n">chopcount</span><span class="p">,</span> <span class="n">cwhoisontheroute</span><span class="p">)</span>

        <span class="c1"># Then iterate as long as the network manager says the network is</span>
        <span class="c1"># running.</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">is_running</span><span class="p">:</span>            
            <span class="n">logging</span><span class="o">.</span><span class="n">debug3</span><span class="p">(</span><span class="s2">&quot;Batching round </span><span class="si">{}</span><span class="s2"> for node </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
            
            <span class="c1"># Test whether the node is &quot;idle&quot; or not. I.e. if the node has no</span>
            <span class="c1"># incoming messages AND has no non-dummy messages to send</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_real_msgs</span> \
               <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">n_real</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_msg_pools</span><span class="p">))</span> \
               <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_process_is_idle</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Ugly &quot;tweak&quot; below: by the way SimPy works, only the last node</span>
                <span class="c1"># needs to check termination of the system. This avoids useless</span>
                <span class="c1"># calls to ``check_network_idleness``</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">nb_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">check_network_idleness</span><span class="p">()</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_process_is_idle</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="c1"># Whether the node is idle or not, it still needs to look at the</span>
            <span class="c1"># messages it received (at least to count the number of dummy</span>
            <span class="c1"># messages it received), and to send out messages (at least to send</span>
            <span class="c1"># one dummy to each neighbor). A node may start a round being</span>
            <span class="c1"># flagged &quot;idle&quot;, and become &quot;non-idle&quot; during that round</span>
            
                        
            <span class="c1"># First, look at messages received in the previous round</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_round_process_received_messages</span><span class="p">()</span>
                        
            <span class="c1"># And secondly, send out what needs to be sent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_round_send_messages</span><span class="p">()</span>
            
            <span class="c1"># Wait for the next round</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">batching_t_interval</span><span class="p">)</span> 
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_round</span><span class="p">()</span>
        
        <span class="c1"># To finish properly, look at the last received messages, which </span>
        <span class="c1"># should always be only dummy messages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_round_process_received_messages</span><span class="p">()</span>
        
        <span class="c1"># When a node comes out of the loop, check that it has indeed finished</span>
        <span class="c1">#all its business</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_msg_pools</span><span class="o">.</span><span class="n">n_real</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_real_msgs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> stopped while it still has pending route proposals:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> stopped while it still has ongoing oriented communications : </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">))</span></div>

    
    
    <span class="k">def</span> <span class="nf">_next_round</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Advances the node to the next batching round</span>
<span class="sd">        </span>
<span class="sd">        This function is called at the end of each round, in particular to</span>
<span class="sd">        increase the batching round number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batching_round</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">next_round</span><span class="p">()</span>
   
            
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Functions relating to the *receiving* of link messages and their</span>
    <span class="c1"># processing</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_receive_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Depose a message in the node&#39;s incoming message box</span>
<span class="sd">        </span>
<span class="sd">        This function is called by other nodes of the network to place a</span>
<span class="sd">        link message in the node&#39;s incoming message box,</span>
<span class="sd">        ``self.__incoming_real_msgs``. This box is emptied at the *next* round, so</span>
<span class="sd">        messages will be counted as received in the next round. Note that dummy</span>
<span class="sd">        messages are simply counted and discarded</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * m (:obj:`~apart.core.message.LinkMsg`): the message </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_is_idle</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">assert</span> <span class="n">m</span><span class="o">.</span><span class="n">sent_by</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">sent_to</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;A message lost its way: </span><span class="si">{}</span><span class="s2"> was received by node </span><span class="si">{}</span><span class="s2"> (which has neighors </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">flag</span> <span class="ow">is</span> <span class="n">MsgFlag</span><span class="o">.</span><span class="n">DUMMY</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nb_incoming_dummy_msgs</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">sent_by</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_real_msgs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            
         
    <span class="k">def</span> <span class="nf">_round_process_received_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>        
        <span class="sd">&quot;&quot;&quot;At the beginning of the round, process the received messages.</span>
<span class="sd">        </span>
<span class="sd">        Function called at the beginning of every round, to loop over the (real)</span>
<span class="sd">        messages received in the previous round. For each type of messages (i.e.</span>
<span class="sd">        for each :class:`MsgFlag`), an different message processing function is</span>
<span class="sd">        called. The incoming traffic counters are also updated in this function.</span>
<span class="sd">        Swap the &quot;incoming_real_msgs&quot; and &quot;nb_incoming_dummy_messages&quot; into</span>
<span class="sd">        local variables, and reinitialize these attributes to empty</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">real_msgs_last_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_real_msgs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__incoming_real_msgs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">nb_dummy_msgs_last_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nb_incoming_dummy_msgs</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">__nb_incoming_dummy_msgs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Update the counters for real and dummy messages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">inc_current_n_i_real</span><span class="p">(</span><span class="n">inc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">real_msgs_last_round</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">n_dum</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nb_dummy_msgs_last_round</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">inc_current_n_i_dum</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="n">n_dum</span><span class="p">)</span>
        
        <span class="c1"># Count the number of received e2e dummies in the round</span>
        <span class="n">nb_e2e_dummy_msgs</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">rcvd_msg</span> <span class="ow">in</span> <span class="n">real_msgs_last_round</span><span class="p">:</span>
<span class="c1">#             rcvd_msg = real_msgs_last_round.pop()</span>
            
            <span class="n">logging</span><span class="o">.</span><span class="n">debug3</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> has received message </span><span class="si">{}</span><span class="s2"> from </span><span class="si">{}</span><span class="s2"> in round </span><span class="si">{}</span><span class="s2"> (time is </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">rcvd_msg</span><span class="p">,</span> <span class="n">rcvd_msg</span><span class="o">.</span><span class="n">sent_by</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">timestamp</span><span class="p">))</span>

            <span class="c1"># Basic check that the message received is indeed intended to the node</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">rcvd_msg</span><span class="o">.</span><span class="n">sent_to</span><span class="p">),</span> <span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> received a message not intended to it: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">rcvd_msg</span><span class="p">)</span>

            <span class="c1"># Handle the received message appropriately, in accordance with the</span>
            <span class="c1"># dictionary handle_msg (that acts as a switch/case).</span>
        
            <span class="k">assert</span> <span class="n">rcvd_msg</span><span class="o">.</span><span class="n">flag</span> <span class="ow">in</span> <span class="n">Node</span><span class="o">.</span><span class="n">__msg_handlers</span><span class="p">,</span> <span class="s2">&quot;Protocol error: node </span><span class="si">{}</span><span class="s2"> received a link message of unsupported type </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">Message is : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">rcvd_msg</span><span class="o">.</span><span class="n">flag</span><span class="p">,</span> <span class="n">rcvd_msg</span><span class="p">)</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Node</span><span class="o">.</span><span class="n">__msg_handlers</span><span class="p">[</span><span class="n">rcvd_msg</span><span class="o">.</span><span class="n">flag</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">rcvd_msg</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">EndToEndDummyError</span><span class="p">:</span>
                <span class="c1"># If this exception is raised, that means (i) that the message</span>
                <span class="c1"># was a payload one and (ii) that is was actually and end to end</span>
                <span class="c1"># dummy</span>
                <span class="n">nb_e2e_dummy_msgs</span> <span class="o">+=</span> <span class="mi">1</span>
            
        
        <span class="n">logging</span><span class="o">.</span><span class="n">debug2</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2">, at round </span><span class="si">{}</span><span class="s2">, has received </span><span class="si">{}</span><span class="s2"> real messages (including </span><span class="si">{}</span><span class="s2"> e2edum) and </span><span class="si">{}</span><span class="s2"> dummies&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">real_msgs_last_round</span><span class="p">),</span> <span class="n">nb_e2e_dummy_msgs</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nb_dummy_msgs_last_round</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
        
        <span class="c1"># Log the received messages, for experiments and measures on the</span>
        <span class="c1"># protocol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_round_rcvd_msgs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real_msgs_last_round</span><span class="p">,</span> 
                                                        <span class="nb">len</span><span class="p">(</span><span class="n">real_msgs_last_round</span><span class="p">),</span> 
                                                        <span class="nb">sum</span><span class="p">(</span><span class="n">nb_dummy_msgs_last_round</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> 
                                                        <span class="n">nb_e2e_dummy_msgs</span><span class="p">)</span>
    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Functions relating to the *sending* of link messages, message pool</span>
    <span class="c1"># management, and traffic rates enforcement</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_place_msg_in_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">msgs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Puts a message in a neighbor pool.</span>
<span class="sd">            </span>
<span class="sd">        Function used by the node itself, to insert messages in its own neighbor</span>
<span class="sd">        pools. The main reason to do such a function is to automatically modify the</span>
<span class="sd">        ``self._process_is_idle`` flag to ``False``</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * n (int): the neighbor </span>
<span class="sd">            * *msgs (:obj:`~apart.core.messages.LinkMsg`): the messages to insert</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_is_idle</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_msg_placed_in_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">msgs</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_msg_pools</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">add_msgs</span><span class="p">(</span><span class="o">*</span><span class="n">msgs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_round_send_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Send messages at the end of the round.</span>
<span class="sd">        </span>
<span class="sd">        Function called by the node itself (FROM :meth:`.run`) at the end of</span>
<span class="sd">        every round (after the processing of received messages. It follows the</span>
<span class="sd">        batching and dummy policy described in the thesis: sample a batch from</span>
<span class="sd">        neighbor pools, compute traffic rates constraints, adjust the batch to</span>
<span class="sd">        fit the constraints, and send it. If no messages are available in pools,</span>
<span class="sd">        send one dummy to each neighbor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="c1">#         # DEBUG: put stress on node 0 by sending it many messages</span>
<span class="c1">#         if self.id != 0:</span>
<span class="c1">#             entries = self.rt.lookup(fields=[RT.CONE, RT.NEXT_NODE, RT.NEXT_CID], constraints={RT.ACTUAL_RCVR: 0})</span>
<span class="c1">#             if len(entries) &gt; 0:</span>
<span class="c1">#                 entry = random.choice(entries)</span>
<span class="c1">#                 next_node = entry[RT.NEXT_NODE]</span>
<span class="c1">#                 next_cid = entry[RT.NEXT_CID]</span>
<span class="c1">#                 cone = entry[RT.CONE]</span>
<span class="c1">#                 c1 = Elgamal_enc_nopk(cone, 0)</span>
<span class="c1">#                 c2 = Elgamal_enc_nopk(cone, 1)</span>
<span class="c1">#                 for _ in range(3):</span>
<span class="c1">#                     m = LinkMsg(sent_by=self.id, sent_to=next_node, c1=c1, c2=c2, flag=MsgFlag.PAYLOAD, cid=next_cid)</span>
<span class="c1">#                     self._place_msg_in_pool(next_node, m)</span>
            
        
        
        <span class="c1"># Insert dummy messages in a random fraction of neighbor pools</span>
        <span class="n">neighbor_fraction</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dummypol_fdum</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbor_fraction</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_msg_pools</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">add_dummy_msg</span><span class="p">()</span>
            
        
        <span class="c1"># Get the margins that the node has in terms of sending out real messages</span>
        <span class="n">current_equilibrium</span><span class="p">,</span> <span class="n">lbound_real_msgs</span><span class="p">,</span> <span class="n">ubound_real_msgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_rates_round_status</span><span class="p">()</span>
        
        <span class="k">assert</span> <span class="n">lbound_real_msgs</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">current_equilibrium</span> <span class="o">&lt;=</span> <span class="n">ubound_real_msgs</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> &lt;= </span><span class="si">{}</span><span class="s2"> &lt;= </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lbound_real_msgs</span><span class="p">,</span> <span class="n">current_equilibrium</span><span class="p">,</span> <span class="n">ubound_real_msgs</span><span class="p">)</span>
        
        <span class="c1"># Log the equilibrium and bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_traffic_rate_equilibrium</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_equilibrium</span><span class="p">,</span> <span class="n">lbound_real_msgs</span><span class="p">,</span> <span class="n">ubound_real_msgs</span><span class="p">)</span>
        
        <span class="c1"># Example : If lbound_real_msgs = 5, that means the node must send AT</span>
        <span class="c1"># LEAST 5 real messages in this round. Alternatively, by construction of</span>
        <span class="c1"># the protocol, it can also send dummy messages so that its n_o_dum</span>
        <span class="c1"># budget becomes 5 or greater The current_equilibrium gives a hint on</span>
        <span class="c1"># how the node is doing in terms of sending/receiving balance. An</span>
        <span class="c1"># current_equilibrium lower to zero means that the node receiver more</span>
        <span class="c1"># messages than it sent out recently, and greater to zero conversely.</span>
        <span class="c1"># Here, by construction the current_equilibrium is never greater than</span>
        <span class="c1"># zero</span>
        
        <span class="c1"># Transform the current_equilibrium into a sampling bias. The lower</span>
        <span class="c1"># current_equilibrium is (below zero), the larger the bias must towards real</span>
        <span class="c1"># messages We use a simple inverse exponential function, tuned to</span>
        <span class="c1"># return 0.5 if equilibrium is -2.</span>
<span class="c1">#         sample_bias = 1-math.exp(current_equilibrium/(-2/math.log(0.5)))#7.2)</span>
        <span class="n">sample_bias</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ubound_real_msgs</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)))</span><span class="c1">#7.2)</span>
        <span class="k">if</span> <span class="n">sample_bias</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">sample_bias</span> <span class="o">=</span> <span class="mf">0.9999999</span>
        
                
        <span class="n">batches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_msg_pools</span><span class="o">.</span><span class="n">sample_neighbor_batches</span><span class="p">(</span><span class="n">sample_bias</span><span class="p">)</span>
        <span class="c1"># batches = {n1 : {&quot;reals&quot;: ..., &quot;dummies&quot;: ...}, ...}</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;reals&#39;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;dummies&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Unadapted batches of node </span><span class="si">{}</span><span class="s2"> in round </span><span class="si">{}</span><span class="s2"> do not all have the same size:</span><span class="se">\n</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">)</span> <span class="o">+</span> \
                                                                                              <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Neighbor </span><span class="si">{}</span><span class="s2">, len = </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;reals&#39;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;dummies&#39;</span><span class="p">]),</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        
        <span class="c1"># Intervene on the batch if necessary</span>
        <span class="n">batch</span><span class="p">,</span> <span class="n">nb_reals</span><span class="p">,</span> <span class="n">nb_dummies_per_neighbor</span><span class="p">,</span> <span class="n">nb_e2e_dummies</span><span class="p">,</span> <span class="n">batch_interventions</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_batch</span><span class="p">(</span><span class="n">batches</span><span class="p">,</span> <span class="n">current_equilibrium</span><span class="p">,</span> <span class="n">lbound_real_msgs</span><span class="p">,</span> <span class="n">ubound_real_msgs</span><span class="p">)</span>
    
        <span class="n">logging</span><span class="o">.</span><span class="n">debug2</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2">, at round </span><span class="si">{}</span><span class="s2">, is going to send batch with </span><span class="si">{}</span><span class="s2"> real messages (including </span><span class="si">{}</span><span class="s2"> e2edum) and </span><span class="si">{}</span><span class="s2"> dummies&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">,</span> <span class="n">nb_reals</span><span class="p">,</span> <span class="n">nb_e2e_dummies</span><span class="p">,</span> <span class="n">nb_dummies_per_neighbor</span><span class="p">))</span>
        
        <span class="c1"># For measures and experiments on the protocol, record</span>
        <span class="c1"># information on the batch sent out</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_sent_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">nb_reals</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nb_dummies_per_neighbor</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">nb_e2e_dummies</span><span class="p">,</span> <span class="o">**</span><span class="n">batch_interventions</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_traffic_counters</span><span class="p">(</span><span class="n">nb_reals</span><span class="p">,</span> <span class="n">nb_dummies_per_neighbor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_send_batch</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_traffic_rates_round_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the current state of of counters of the controlled traffic rate mechanism.</span>
<span class="sd">        </span>
<span class="sd">        Function called before the sampling of a batch, to get the current state</span>
<span class="sd">        of the controlled traffic rate mechanism</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (int, int, int): the *equilibrium* in terms of sent/received real</span>
<span class="sd">            messages, and the upper and lower bounds on the real messages that</span>
<span class="sd">            can/must be sent in this round.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># An &quot;current_equilibrium&quot; lower than 0 means the node received more messages than</span>
        <span class="c1"># it sent out recently. And conversely if it is greater to 0</span>
        <span class="n">current_equilibrium</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">current_equilibrium</span>
        <span class="n">o_dum_budget</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">total_n_o_dum_budget</span>
        <span class="n">i_dum_budget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">total_n_i_dum_budget</span>
        
        <span class="c1"># From the current_equilibrium and the dummy budgets, bounds on the number and</span>
        <span class="c1"># nature of messages to be sent in the round are deduced. The upper</span>
        <span class="c1"># bound is set so that AT EACH ROUND, the traffic rate equation is</span>
        <span class="c1"># respected (i.e. no n_o_real is left unresolved). But for the lower</span>
        <span class="c1"># bound, we relax the constraint on several rounds. That is, it is</span>
        <span class="c1"># allowed for a node to receive more than it sends out in a round.</span>
        <span class="c1"># However, the upper bound does ensure that AFTER delta_r rounds,</span>
        <span class="c1"># n_o_real is resolved.</span>
        
        <span class="n">ubound_real_msgs</span> <span class="o">=</span> <span class="n">i_dum_budget</span> <span class="o">-</span> <span class="n">current_equilibrium</span>
        <span class="n">lbound_real_msgs</span> <span class="o">=</span> <span class="n">o_dum_budget</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">last_unresolved_n_i_real</span>
        
        <span class="c1"># Note : ``lbound_real_msgs = o_dum_budget - current_equilibrium`` would</span>
        <span class="c1"># be the &quot;stricter&quot; lower bound corresponding to enforcing the traffic</span>
        <span class="c1"># rate equation PERFECTLY AT EACH ROUND, for both sending and receiving</span>
        
        <span class="k">return</span> <span class="n">current_equilibrium</span><span class="p">,</span> <span class="n">lbound_real_msgs</span><span class="p">,</span> <span class="n">ubound_real_msgs</span>
    
    
    <span class="k">def</span> <span class="nf">_adapt_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batches</span><span class="p">,</span> <span class="n">current_equilibrium</span><span class="p">,</span> <span class="n">lbound_real_msgs</span><span class="p">,</span> <span class="n">ubound_real_msgs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Post processing of batches, to adapt them after sampling from the pools.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">        * batches (dict of dict of list of messages): the batches, per neighbor,</span>
<span class="sd">                     divided between reals and dummy ones</span>
<span class="sd">        * current_equilibrium (int): the traffic rate equilibirum in the current</span>
<span class="sd">                    round</span>
<span class="sd">        * lbound_real_msgs (int): the minimum number of rela messages to send in</span>
<span class="sd">                    the round</span>
<span class="sd">        * ubound_real_msgs (int): the maximum number of rela messages to send in</span>
<span class="sd">                    the round</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            * batch (list of messages): the adapted batch, with message for all neighbors</span>
<span class="sd">            * nb_reals (int): the number of real message sin the batch</span>
<span class="sd">            * nb_dummies_per_neighbors (dict int-&gt;int): the number of dummy messages per neighbor</span>
<span class="sd">            * nb_e2e_dummies (int): the number of end to end dummy message sin the batch</span>
<span class="sd">            * batch_interventions (dict str-&gt;int): the nature of the modifications made on the batch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_reals</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;reals&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">nb_dummies_per_neighbor</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;dummies&#39;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">nb_e2e_dummies</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># For statistics and measures on the protocol, log the modifications made on the batch</span>
        <span class="n">batch_interventions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;remove_real&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;replace_dummy_by_e2e_dummy&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="s1">&#39;add_e2e_dummy&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;add_many_dummies&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="s1">&#39;default_dummy_broadcast&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        
        <span class="c1"># Adjust the batch to fit into the bounds posed by the controlled</span>
        <span class="c1"># traffic rates</span>
        <span class="k">while</span> <span class="n">nb_reals</span> <span class="o">&gt;</span> <span class="n">ubound_real_msgs</span><span class="p">:</span>
            <span class="c1"># Select a batch from any neighbor that has at least one real</span>
            <span class="c1"># message, and replace the first real message in that batch with</span>
            <span class="c1"># a dummy</span>
            <span class="n">n</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;reals&#39;</span><span class="p">]])</span>
            <span class="n">b</span><span class="p">[</span><span class="s1">&#39;reals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">b</span><span class="p">[</span><span class="s1">&#39;dummies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LinkMsg</span><span class="o">.</span><span class="n">create_dummy</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>
            <span class="n">nb_reals</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">nb_dummies_per_neighbor</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">batch_interventions</span><span class="p">[</span><span class="s1">&#39;remove_real&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">nb_reals</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">nb_dummies_per_neighbor</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">lbound_real_msgs</span><span class="p">:</span>
            <span class="c1"># Two options : augment min(dummies)  with simple dummy messages, </span>
            <span class="c1"># or nb_reals with end to end dummy messages. BUT recall that</span>
            <span class="c1"># e2e dummy can not always be sent, especially at the beginning </span>
            <span class="c1"># of the network life.</span>
            <span class="c1"># We choose the</span>
            <span class="c1"># following : if there exist a neighbor batch in which removing a</span>
            <span class="c1"># dummy does not decrease min(dummies), replace a dummy in this</span>
            <span class="c1"># batch by and end-to-end dummy. Otherwise, add one end-to-end</span>
            <span class="c1"># dummy and n-1 link dummies. And during these operations, if</span>
            <span class="c1"># no neighbor could be found to send an end-to-end dummy, we</span>
            <span class="c1"># simply fill the gap with link dummies</span>
            <span class="n">intervention_ok</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># First, look if we can replace a link dummy with an e2e dummy</span>
            <span class="n">min_nb_dummies</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nb_dummies_per_neighbor</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">potential_neighbors</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;dummies&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">min_nb_dummies</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">potential_neighbors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">potential_neighbors</span><span class="p">)</span>
                <span class="c1"># Even though we want to send one e2e dummy to one neighbor,</span>
                <span class="c1"># we have to test them all: at the beginning of the network,</span>
                <span class="c1"># a node has actually no route in its RT, and thus no way to</span>
                <span class="c1"># send e2e. Here, we hope that the node knows at least one</span>
                <span class="c1"># route, and we must find the neighbor that begins it</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">potential_neighbors</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">b</span><span class="p">[</span><span class="s1">&#39;reals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_craft_e2e_dummy</span><span class="p">(</span><span class="n">to_neighbor</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>
                        <span class="n">b</span><span class="p">[</span><span class="s1">&#39;dummies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">nb_reals</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">nb_dummies_per_neighbor</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">nb_e2e_dummies</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">batch_interventions</span><span class="p">[</span><span class="s1">&#39;replace_dummy_by_e2e_dummy&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">intervention_ok</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="k">except</span> <span class="n">EndToEndDummyError</span><span class="p">:</span>
                        <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">intervention_ok</span><span class="p">:</span>
                <span class="c1"># Otherwise if the above trial of intervention failed, try to add</span>
                <span class="c1"># one e2e dummy and k-1 link dummies (k = nb neighbors)</span>
                <span class="n">shuffled_neighbors</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">))</span>
                <span class="c1"># The for loop here is in the same idea as the preceding one: we test all neighbors to see if one</span>
                <span class="c1"># can actually get a e2e dummy.</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">batches</span><span class="p">[</span><span class="n">shuffled_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;reals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_craft_e2e_dummy</span><span class="p">(</span><span class="n">to_neighbor</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">shuffled_neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="n">batches</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;dummies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LinkMsg</span><span class="o">.</span><span class="n">create_dummy</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">n2</span><span class="p">))</span>
                            <span class="n">nb_dummies_per_neighbor</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">nb_reals</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">nb_e2e_dummies</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">batch_interventions</span><span class="p">[</span><span class="s1">&#39;add_e2e_dummy&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">intervention_ok</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="k">except</span> <span class="n">EndToEndDummyError</span><span class="p">:</span>
                        <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">intervention_ok</span><span class="p">:</span>
                <span class="c1"># If still the above two trial of intervention failed</span>
                <span class="c1"># (normally, because no neighbor can receive an e2e dummy,</span>
                <span class="c1"># which happends at the beginning of the network life, when</span>
                <span class="c1"># the node does not know any route), we need to resort</span>
                <span class="c1"># solely to link  dummies: add the same amount of link dummy</span>
                <span class="c1"># message to each neighbor</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">lookup</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">nb_dum_missing</span> <span class="o">=</span> <span class="n">lbound_real_msgs</span> <span class="o">-</span> <span class="n">nb_reals</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">nb_dummies_per_neighbor</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">:</span>
                    <span class="n">batches</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;dummies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">LinkMsg</span><span class="o">.</span><span class="n">create_dummy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_dum_missing</span><span class="p">)))</span>
                    <span class="n">nb_dummies_per_neighbor</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nb_dum_missing</span>
                <span class="n">batch_interventions</span><span class="p">[</span><span class="s1">&#39;add_many_dummies&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                
        
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;reals&#39;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;dummies&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Batches of node </span><span class="si">{}</span><span class="s2"> in round </span><span class="si">{}</span><span class="s2"> do not all have the same size:</span><span class="se">\n</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">)</span> <span class="o">+</span> \
                                                                                              <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Neighbor </span><span class="si">{}</span><span class="s2">, len = </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;reals&#39;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;dummies&#39;</span><span class="p">]),</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span> <span class="o">+</span>\
                                                                                              <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Interventions on batch : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">batch_interventions</span><span class="p">)</span> <span class="o">+</span> \
                                                                                              <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Btw, my neighbors are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">)</span>
                                                                                              
        
        <span class="c1"># After this phase, validate the removal of the selected messages from the pools</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_msg_pools</span><span class="o">.</span><span class="n">remove_batches</span><span class="p">(</span><span class="n">batches</span><span class="p">)</span>
        
        <span class="c1"># Merge all in one big batch</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;reals&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;dummies&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">batches</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
                
        <span class="c1"># After all this, if the batch turns out to be empty  (e.g. because</span>
        <span class="c1"># no message is available from the pools), send one dummy to each</span>
        <span class="c1"># neighbor</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">batch</span> <span class="o">=</span> <span class="p">[</span><span class="n">LinkMsg</span><span class="o">.</span><span class="n">create_dummy</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">]</span>
            <span class="n">nb_dummies_per_neighbor</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">)</span>
            <span class="n">nb_reals</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nb_e2e_dummies</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">batch_interventions</span><span class="p">[</span><span class="s1">&#39;default_dummy_broadcast&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Just a simple verification: that when real msgs must be removed, the number of dummies do not need to be modified (I think that would mean that lbound &lt; ubound...)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">batch_interventions</span><span class="p">[</span><span class="s1">&#39;remove_real&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">batch_interventions</span><span class="p">[</span><span class="s1">&#39;replace_dummy_by_e2e_dummy&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">batch_interventions</span><span class="p">[</span><span class="s1">&#39;add_e2e_dummy&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">batch_interventions</span><span class="p">[</span><span class="s1">&#39;add_many_dummies&#39;</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">batch</span><span class="p">,</span> <span class="n">nb_reals</span><span class="p">,</span> <span class="n">nb_dummies_per_neighbor</span><span class="p">,</span> <span class="n">nb_e2e_dummies</span><span class="p">,</span> <span class="n">batch_interventions</span>
    
    <span class="k">def</span> <span class="nf">_update_traffic_counters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb_sent_real_msgs</span><span class="p">,</span> <span class="n">nb_sent_dummy_msgs_per_neighbor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the traffic counters for the controlled traffic rates mechanism</span>
<span class="sd">        </span>
<span class="sd">        Function called after the formation (and adjustment) of the batch, to</span>
<span class="sd">        update the traffic counters.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * nb_sent_real_msgs (int): the number of sent real messages in the</span>
<span class="sd">                                    current round</span>
<span class="sd">            * nb_sent_dummy_msgs_per_neighbor (dict of int-&gt;int): the number of</span>
<span class="sd">                                    sent real dummy per neighbor in the </span>
<span class="sd">                                    current round</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
        <span class="c1"># Update the n_o_real and n_o_dum counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">inc_current_n_o_real</span><span class="p">(</span><span class="n">inc</span><span class="o">=</span><span class="n">nb_sent_real_msgs</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nb_sent_dummy_msgs_per_neighbor</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">inc_current_n_o_dum</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
        
        <span class="c1"># Then, equilibrate the sending and receiving counters : whichever is</span>
        <span class="c1"># bigger than the other is going to &quot;consume&quot; the unresolved other</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">equilibrate_n_o_real_and_n_i_real</span><span class="p">()</span>
        
        <span class="c1"># If n_o_real is still unresolved, resolve it further with the n_i_dum</span>
        <span class="c1"># budget. By the &quot;strict&quot; upper bound enforced above, there should be no</span>
        <span class="c1"># remaining unresolved n_o_real, but let&#39;s check anyway</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">resolve_n_o_real_with_dummies</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">total_unresolved_n_o_real</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Sending budget of node </span><span class="si">{}</span><span class="s2"> not large enough to send </span><span class="si">{}</span><span class="s2"> real messages.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">nb_sent_real_msgs</span><span class="p">)</span>
        
        <span class="c1"># Secondly, see if the n_o_dum budget can take of some of the unresolved</span>
        <span class="c1"># n_i_real, if the later is not zero by now. Contrarily to the case above</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">resolve_n_i_real_with_dummies</span><span class="p">()</span>
        <span class="c1"># However, the value of the round r-delta_r must be resolved by now</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__traffic_counters</span><span class="o">.</span><span class="n">last_unresolved_n_i_real</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Not all constraints were resolved within the round window: n_i_real(delta_r) still unresolved.&quot;</span>
        

    <span class="k">def</span> <span class="nf">_craft_e2e_dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_neighbor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates and returns an end-to-end dummy message.</span>
<span class="sd">        </span>
<span class="sd">        Helper function, called during the adjustment of the sampled batch to</span>
<span class="sd">        the traffic rates constraints, to craft an end-to-end dummy message</span>
<span class="sd">        towards a random receiver, with the constraint that the route must begin</span>
<span class="sd">        with neighbor specified by ``to_neighbor``</span>
<span class="sd">        </span>
<span class="sd">        If for some reason, the node does not have a route beginning with the </span>
<span class="sd">        specified neighbor, the function raises an error </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * to_neighbor (int): The neighbor to sent the e2e dummy to.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (:obj:`~apart.core.messages.LinkMsg` or None): the e2e message</span>
<span class="sd">            </span>
<span class="sd">        Raise:</span>
<span class="sd">            :exc:`~apart.core.message.EndToEndDummyError`: If no route beginning with the</span>
<span class="sd">                                    specified neighbor was found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Search the routing table for a route that has the specified neighbor as next hop</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">],</span> <span class="n">constraints</span><span class="o">=</span><span class="p">{</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">:</span> <span class="n">to_neighbor</span><span class="p">})</span>
        
        <span class="c1"># No entries found means no route with this next hop</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EndToEndDummyError</span><span class="p">(</span><span class="s2">&quot;No route beginning with neighbor </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_neighbor</span><span class="p">))</span>


        <span class="n">entry</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">],</span> <span class="n">MsgInnerHeader</span><span class="p">(</span><span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">DUMMY</span><span class="p">))</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">],</span> <span class="n">MsgInnerHeader</span><span class="p">(</span><span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">DUMMY</span><span class="p">))</span>
        <span class="n">cid</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">]</span>
        <span class="n">actual_rcvr</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">to_neighbor</span><span class="p">,</span> 
                       <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                       <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">PAYLOAD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">cid</span><span class="p">,</span> 
                       <span class="n">additional_info</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;end_sender&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;end_rcvr&#39;</span><span class="p">:</span> <span class="n">actual_rcvr</span><span class="p">,</span> <span class="s1">&#39;is_e2e_dummy&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
    
    <span class="k">def</span> <span class="nf">_send_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sends out a batch of messages, simulating latency in delivery.</span>
<span class="sd">        </span>
<span class="sd">        Function that does the sending of a whole batch of message. The batch</span>
<span class="sd">        contains a heterogeneous collection of messages for different neighbors.</span>
<span class="sd">        It is here that is computed the simulated the time taken to send (and</span>
<span class="sd">        process) all these messages. This latency is actually simulated in</span>
<span class="sd">        :meth:`_do_send_link_msg`. Note that, if there are really many messages in</span>
<span class="sd">        the batch, the simulated latency added in this function might exceed the</span>
<span class="sd">        time of a round. We&#39;ll see what happens in that case</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * batch (:class:`list` of :obj:`~apart.core.messages.LinkMsg`): the</span>
<span class="sd">                            batch of link messages to send</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Make sure messages are sent in random order</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>
        
        <span class="c1"># Simulation of the the latency in the sending and propagation of link</span>
        <span class="c1"># messages</span>
        <span class="n">base_latency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">communication_latency</span>
        <span class="n">accumulated_latency</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># If implemented, AES encryption of headers should be done here: fetch</span>
        <span class="c1"># link keys in KeyTable, encrypt header *in place*, send message</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">:</span>
            <span class="c1"># The latency is accumulated</span>
            <span class="n">accumulated_latency</span> <span class="o">+=</span> <span class="nb">round</span><span class="p">(</span><span class="n">base_latency</span><span class="o">*</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">accumulated_latency</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">batching_t_interval</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_do_send_link_msg</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">accumulated_latency</span><span class="p">)</span>

            
    <span class="k">def</span> <span class="nf">_do_send_link_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">latency</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sends one link message to a neighbor, with some delivery latency.</span>
<span class="sd">        </span>
<span class="sd">        Simulates the latency in each message sending using a SimPy timeout event,</span>
<span class="sd">        and delivers the message to the adequate node&#39;s</span>
<span class="sd">        ``self.__incoming_real_msgs`` box</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * m (:obj:`~apart.core.messages.LinkMsg`): the link message to send.</span>
<span class="sd">            * latency (int): the delivery latency to simuulate.</span>
<span class="sd">        &quot;&quot;&quot;</span>   
        
        <span class="k">def</span> <span class="nf">delayed_send_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">value</span>
            <span class="c1"># Send the message to the adequate neighbor</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug3</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> is sending msg </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> in round </span><span class="si">{}</span><span class="s2"> (time is</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">sent_by</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">sent_to</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">sent_by</span><span class="p">]</span><span class="o">.</span><span class="n">batching_round</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">timestamp</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">sent_to</span><span class="p">]</span><span class="o">.</span><span class="n">_receive_msg</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        
        <span class="c1"># Create a timeout event with the specified latency, and &quot;manually&quot;</span>
        <span class="c1"># register the callback to effectivelly send the message (manually as</span>
        <span class="c1"># opposed to using &quot;yield&quot;)</span>
        <span class="n">timeout_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">latency</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">timeout_event</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delayed_send_callback</span><span class="p">)</span>  


    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Functions relating to route proposals and topology dissemination. Some</span>
    <span class="c1"># functions are message handlers, called by</span>
    <span class="c1"># :meth:`self._round_process_received_messages`. They are denoted by a</span>
    <span class="c1"># &quot;_handle&quot; prefix</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_propose_route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rt_entry</span><span class="p">,</span> <span class="n">cprop</span><span class="p">,</span> <span class="n">cone</span><span class="p">,</span> <span class="n">chopcount</span><span class="p">,</span> <span class="n">cwhoisontheroute</span><span class="p">,</span> <span class="n">except_neighbor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Makes the node propose a routing table entry to its neighbors</span>
<span class="sd">        </span>
<span class="sd">        This function makes self-proposals as well as relayed ones. It is based</span>
<span class="sd">        on a routing table entry, and is provided with all the ciphertexts to</span>
<span class="sd">        include in the rt prop messages. </span>
<span class="sd">        </span>
<span class="sd">        In the case of a relayed proposition, ``except_neighbor`` will be equal</span>
<span class="sd">        to the neighbor from which the node just acquired the route. Indeed, it</span>
<span class="sd">        is useless to propose the route to the one that proposed it.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * rt_entry (:obj:`dict` or :obj:`sqlite3.Row`): the routing table entry to propose</span>
<span class="sd">            * cprop (:obj:`~apart.crypto.crypto.Ctxt`): the ciphertext containing the *dst* value of the receiver</span>
<span class="sd">            * cone (:obj:`~apart.crypto.crypto.Ctxt`): the ciphertext of one, for (re-)encryption</span>
<span class="sd">            * chopcount (:obj:`~apart.crypto.crypto.Ctxt`): the ciphertext containing the length of the route being proposed</span>
<span class="sd">            * cwhoisontheroute (:class:`~apart.crypto.crypto.Ctxt`): the ciphertext containing the nodes alreeady on the route proposed</span>
<span class="sd">            * except_neighbor (int): the neighbor to which the node must *not* propose the route </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> is proposing a route towards node </span><span class="si">{}</span><span class="s2"> at round </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">))</span>
        
        <span class="c1"># Create one route proposal for each neighbor</span>
        <span class="n">prt_entries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">additional_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;actual_rcvr&#39;</span><span class="p">:</span> <span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">],</span> <span class="s1">&#39;actual_proposer&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> 
                           <span class="s1">&#39;actual_proposee&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;round_rt_prop_started&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">,</span> 
                           <span class="s1">&#39;actual_length&#39;</span><span class="p">:</span> <span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_LENGTH</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span>
        
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">except_neighbor</span><span class="p">):</span>
            <span class="n">new_cid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">get_next_cid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;actual_proposee&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">msg_additional_info</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">additional_info</span><span class="p">)</span>
            
            <span class="n">rt_prop_msg_1</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>  
                                  <span class="n">c1</span><span class="o">=</span><span class="n">cprop</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">cone</span><span class="p">,</span>
                                  <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">new_cid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  
                                  <span class="n">additional_info</span><span class="o">=</span><span class="n">msg_additional_info</span><span class="p">)</span>
            <span class="n">rt_prop_msg_2</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>  
                                  <span class="n">c1</span><span class="o">=</span><span class="n">chopcount</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">cwhoisontheroute</span><span class="p">,</span>
                                  <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">new_cid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                  <span class="n">additional_info</span><span class="o">=</span><span class="n">msg_additional_info</span><span class="p">)</span>
            
            <span class="c1"># Insert both messages in the pool for neighbor n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">rt_prop_msg_1</span><span class="p">,</span> <span class="n">rt_prop_msg_2</span><span class="p">)</span>
            
            <span class="c1"># Note the new &quot;previous hops&quot; that may be formed at the end of the proposal</span>
            <span class="n">prt_entries</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">PRT</span><span class="o">.</span><span class="n">PREV_NODE</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="n">PRT</span><span class="o">.</span><span class="n">PREV_CID</span><span class="p">:</span> <span class="n">new_cid</span><span class="p">,</span> 
                                <span class="n">PRT</span><span class="o">.</span><span class="n">RT_ROWID</span><span class="p">:</span> <span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">]})</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;sent&#39;</span><span class="p">][(</span><span class="n">n</span><span class="p">,</span> <span class="n">new_cid</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;is_selfprop&#39;</span><span class="p">:</span> <span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> 
                                                            <span class="s1">&#39;proposee&#39;</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39;cid&#39;</span><span class="p">:</span> <span class="n">new_cid</span><span class="p">,</span>
                                                            <span class="s1">&#39;proposed_rt_entry_id&#39;</span><span class="p">:</span> <span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">],</span>
                                                            <span class="s1">&#39;additional_info&#39;</span><span class="p">:</span> <span class="n">additional_info</span><span class="p">}</span>
            
            

        <span class="c1"># Log the rt prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_rt_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;proposed&#39;</span><span class="p">,</span> <span class="n">nb_to_log</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">prt_entries</span><span class="p">))</span>
        
        <span class="c1"># Insert all prt entries in one go</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prt</span><span class="o">.</span><span class="n">insert_entries</span><span class="p">(</span><span class="n">prt_entries</span><span class="p">)</span>
        
    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Route proposals: Proposee, step 1</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_handle_rt_prop_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rt_prop_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler of :attr:`~apart.core.messages.MsgFlag.RTPROP` messages (received by proposee)</span>
<span class="sd">        </span>
<span class="sd">        A route proposal starts with *two*</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP` messages. The one called</span>
<span class="sd">        &quot;the first&quot; contains the encrypted dst value, the one called &quot;the second&quot; contains </span>
<span class="sd">        information on the route, to be used as part of the route proposal</span>
<span class="sd">        policy. Throughout the whole route proposal, these two messages are going to be</span>
<span class="sd">        carried around, from proposer to proposee, and from proposer to relay</span>
<span class="sd">        nodes to receiver and back.</span>
<span class="sd">        </span>
<span class="sd">        This function waits for the two</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP` before calling</span>
<span class="sd">        :meth:`._proposee_answer_rt_prop` to proces sthe route proposal, and</span>
<span class="sd">        answer to the proposer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
        <span class="c1"># When a node receives a rt prop message, it can not process it straight</span>
        <span class="c1"># away. It must wait for the other rt prop message. These two messages</span>
        <span class="c1"># may arrive in any order.</span>
        <span class="n">new_cid</span> <span class="o">=</span> <span class="n">rt_prop_msg</span><span class="o">.</span><span class="n">cid</span>
        <span class="n">proposer</span> <span class="o">=</span> <span class="n">rt_prop_msg</span><span class="o">.</span><span class="n">sent_by</span>
        <span class="n">is_fst_protocol_msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rt_prop_msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">proposer</span><span class="p">,</span> <span class="n">new_cid</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;rcvd&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;rcvd&#39;</span><span class="p">][(</span><span class="n">proposer</span><span class="p">,</span> <span class="n">new_cid</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;proposer&#39;</span><span class="p">:</span> <span class="n">proposer</span><span class="p">,</span> <span class="s1">&#39;cid&#39;</span><span class="p">:</span> <span class="n">new_cid</span><span class="p">,</span>
                                                                 <span class="s1">&#39;additional_info&#39;</span><span class="p">:</span> <span class="n">rt_prop_msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">}</span>
        
        <span class="n">pending_rt_prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;rcvd&#39;</span><span class="p">][(</span><span class="n">proposer</span><span class="p">,</span> <span class="n">new_cid</span><span class="p">)]</span>
            
        <span class="k">if</span> <span class="n">is_fst_protocol_msg</span><span class="p">:</span>
            <span class="n">pending_rt_prop</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;cprop&#39;</span><span class="p">:</span> <span class="n">rt_prop_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span>
                                    <span class="s1">&#39;cone&#39;</span><span class="p">:</span> <span class="n">rt_prop_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pending_rt_prop</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;chopcount&#39;</span><span class="p">:</span> <span class="n">rt_prop_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span>
                                    <span class="s1">&#39;cwhoisontheroute&#39;</span><span class="p">:</span> <span class="n">rt_prop_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">})</span>
            
        <span class="k">if</span> <span class="s1">&#39;cprop&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span> <span class="ow">and</span> <span class="s1">&#39;chopcount&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proposee_answer_rt_prop</span><span class="p">(</span><span class="n">pending_rt_prop</span><span class="p">)</span>
            
    <span class="k">def</span> <span class="nf">_proposee_answer_rt_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process a route proposal as a proposee (first step)</span>
<span class="sd">        </span>
<span class="sd">        The node processes ciphertexts, in particular computing dst**src</span>
<span class="sd">        (homomorphically) for the pseudonym, and then sends back two</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_ANSWER` messages to the</span>
<span class="sd">        proposer. </span>
<span class="sd">        </span>
<span class="sd">        To allow the proposer to differentiate the first message (containing</span>
<span class="sd">        dst**src encrypted notably) from the second one (containing the yes/no</span>
<span class="sd">        answer stating whether the proposee accepts the route or not), the later</span>
<span class="sd">        has a cid that we say *related* to the first message&#39;s cid. The domain</span>
<span class="sd">        of cids and related cids are not overlapping (see</span>
<span class="sd">        :meth:`~apart.core.network.Network.get_related_cid`)</span>
<span class="sd">        &quot;&quot;&quot;</span>  
        
        <span class="c1"># When both the rt prop and the rt prop additional info messages were</span>
        <span class="c1"># received, process the route proposition</span>
        <span class="n">proposer</span> <span class="o">=</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;proposer&#39;</span><span class="p">]</span>
        <span class="n">cid</span> <span class="o">=</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cid&#39;</span><span class="p">]</span>
        <span class="n">cprop</span> <span class="o">=</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cprop&#39;</span><span class="p">]</span>
        <span class="n">cone</span> <span class="o">=</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cone&#39;</span><span class="p">]</span>
        <span class="n">chopcount</span> <span class="o">=</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;chopcount&#39;</span><span class="p">]</span>
        <span class="n">cwhoisontheroute</span> <span class="o">=</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cwhoisontheroute&#39;</span><span class="p">]</span>
        
        
        <span class="c1"># Log the_rt prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_rt_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;received&#39;</span><span class="p">)</span>
        
        <span class="c1"># Generate a temporary key pair</span>
        <span class="p">(</span><span class="n">pk_tmp</span><span class="p">,</span> <span class="n">sk_tmp</span><span class="p">)</span> <span class="o">=</span> <span class="n">Elgamal_keygen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">secparam</span><span class="p">)</span>
        
        
        <span class="c1"># Process the base ciphertexts</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">Elgamal_scalar_exp</span><span class="p">(</span><span class="n">cprop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src</span><span class="p">))</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">pk_tmp</span><span class="p">)</span>
        
        <span class="c1"># c3 and c4 are supposed to each contains a yes/no answer </span>
        <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proposee_route_proposal_policy_encrypted_decision</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">chopcount</span><span class="p">,</span> <span class="n">cwhoisontheroute</span><span class="p">)</span>
        
        <span class="n">rt_prop_answer_msg_1</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">proposer</span><span class="p">,</span> 
                                       <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_ANSWER</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">cid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rt_prop_answer_msg_2</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">proposer</span><span class="p">,</span> 
                                       <span class="n">c1</span><span class="o">=</span><span class="n">c3</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c4</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_ANSWER</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">cid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        
         
        <span class="c1"># Insert both messages in the pool for the adequate neighbor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">proposer</span><span class="p">,</span> <span class="n">rt_prop_answer_msg_1</span><span class="p">,</span> <span class="n">rt_prop_answer_msg_2</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;rcvd&#39;</span><span class="p">][(</span><span class="n">proposer</span><span class="p">,</span> <span class="n">cid</span><span class="p">)][</span><span class="s1">&#39;tmpkeypair&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pk_tmp</span><span class="p">,</span> <span class="n">sk_tmp</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_proposee_route_proposal_policy_encrypted_decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cone</span><span class="p">,</span> <span class="n">chopcount</span><span class="p">,</span> <span class="n">cwhoisontheroute</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes and returns the encrypted the yes/no answer stating whether the proposee accepts the route or not</span>
<span class="sd">        </span>
<span class="sd">        Called by the receiver on the ciphertexts contained in the</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_INFO` message, this function</span>
<span class="sd">        returns two ciphertexts. The first contains g**(lmax-l), and the second</span>
<span class="sd">        g**0/1. These will eventually be given to the end-receiver, who will</span>
<span class="sd">        transform that into a yes/no answer (see :meth:`._receiver_process_rt_prop`</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * cone (Ctxt): one encrypted under the same pk as the other two </span>
<span class="sd">                            ciphertexts (used for re-encryption)</span>
<span class="sd">            * chopcount (Ctxt): encrypts g**l, received by the proposee in a </span>
<span class="sd">                            :attr:`~apart.core.messages.MsgFlag.RTPROP_INFO` message</span>
<span class="sd">            * cwhoisontheroute (Ctxt): encrypts [n1, n2, ...], received by the proposee </span>
<span class="sd">                                        in a :attr:`~apart.core.messages.MsgFlag.RTPROP_INFO` message</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            * cdecision_hopcount (Ctxt): the value lmax-l encrypted</span>
<span class="sd">            * cdecision_loop (Ctxt): ciphertext encrypting ``True`` if the node is already on the route</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cmaxhopcount</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="n">GROUP_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">rtprop_policy_max_hop_count</span><span class="p">))</span>
        <span class="n">cdecision_hopcount</span> <span class="o">=</span> <span class="n">Elgamal_ctxt_div</span><span class="p">(</span><span class="n">cmaxhopcount</span><span class="p">,</span> <span class="n">chopcount</span><span class="p">)</span>
        <span class="n">cdecision_loop</span> <span class="o">=</span> <span class="n">Elgamal_accumulator_check</span><span class="p">(</span><span class="n">cwhoisontheroute</span><span class="p">,</span> <span class="s2">&quot; </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cdecision_hopcount</span><span class="p">,</span> <span class="n">cdecision_loop</span>
    
        
    
    
    
    
    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Route proposals: Proposer, step 2</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_handle_rt_prop_answer_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rt_prop_answer_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler of :attr:`~apart.core.messages.MsgFlag.RTPROP_ANSWER` messages  (received by proposer)</span>
<span class="sd">        </span>
<span class="sd">        Two cases arise: the proposer is also the receiver (self-proposal), or</span>
<span class="sd">        not. In the first case, the proposer waits for the *two*</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_ANSWER` messages, processes</span>
<span class="sd">        them (by calling :meth:`._receiver_process_rt_prop`), and sends back two</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_FINAl` messages (by calling</span>
<span class="sd">        :meth:`._proposer_send_rt_prop_final_msg`).</span>
<span class="sd">        </span>
<span class="sd">        In the second case, the proposer will sent the ciphertexts on a return</span>
<span class="sd">        trip to the distant receiver. For that, it can process the two</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_ANSWER` messages</span>
<span class="sd">        independently, and forward each one as soon as it receives in,</span>
<span class="sd">        transforming it into a</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` message (by</span>
<span class="sd">        calling :meth:`._rt_prop_return_trip_relay_fwd`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The proposer excepts to receive *two* rt prop answer messages. They</span>
        <span class="c1"># may arrive in any order. In the case of a self-proposition, the</span>
        <span class="c1"># proposer must wait for both messages to arrive two before processing</span>
        <span class="c1"># them. In case of a relayed proposition, they can be processed independently</span>
        <span class="n">proposee</span> <span class="o">=</span> <span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">sent_by</span>
        <span class="n">cid</span> <span class="o">=</span> <span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">cid</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">proposee</span><span class="p">,</span> <span class="n">cid</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;sent&#39;</span><span class="p">]</span>
        <span class="n">pending_rt_prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;sent&#39;</span><span class="p">][(</span><span class="n">proposee</span><span class="p">,</span> <span class="n">cid</span><span class="p">)]</span>
        <span class="n">is_fst_protocol_msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;is_selfprop&#39;</span><span class="p">]:</span>
            <span class="c1"># The node is the self-proposer. Consequently wait for both rt prop</span>
            <span class="c1"># answer messages to be received</span>
            <span class="k">if</span> <span class="n">is_fst_protocol_msg</span><span class="p">:</span>
                <span class="c1"># This is the first rt prop answer message</span>
                <span class="n">pending_rt_prop</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;cpseudo&#39;</span><span class="p">:</span> <span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span>
                                        <span class="s1">&#39;cpktmp&#39;</span><span class="p">:</span> <span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This is the second rt prop answer message </span>
                <span class="n">pending_rt_prop</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;caccept_hopcount&#39;</span><span class="p">:</span> <span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> 
                                        <span class="s1">&#39;caccept_loop&#39;</span><span class="p">:</span> <span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">})</span>
            
            <span class="c1"># When both are received, answer to the proposee</span>
            <span class="k">if</span> <span class="s1">&#39;cpseudo&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span> <span class="ow">and</span> <span class="s1">&#39;caccept_hopcount&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span><span class="p">:</span>
                <span class="n">ctxts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receiver_process_rt_prop</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">pending_rt_prop</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span> <span class="k">for</span> <span class="n">cname</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cpseudo&#39;</span><span class="p">,</span> <span class="s1">&#39;cpktmp&#39;</span><span class="p">,</span> <span class="s1">&#39;caccept_hopcount&#39;</span><span class="p">,</span> <span class="s1">&#39;caccept_loop&#39;</span><span class="p">]])</span>
    
                <span class="bp">self</span><span class="o">.</span><span class="n">_proposer_send_rt_prop_final_msg</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">proposee</span><span class="p">,</span> <span class="n">cid</span><span class="p">,</span> <span class="n">ctxts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctxts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_proposer_send_rt_prop_final_msg</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">proposee</span><span class="p">,</span> <span class="n">cid</span><span class="p">,</span> <span class="n">ctxts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctxts</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                
                <span class="c1"># Deleted the ongoing rt prop entry</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;sent&#39;</span><span class="p">][(</span><span class="n">proposee</span><span class="p">,</span> <span class="n">cid</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The proposer is not the receiver. It must &quot;tranform&quot; the rt prop</span>
            <span class="c1"># answer msgs into rt prop relay fwd ones, and act &quot;as if&quot; it was</span>
            <span class="c1"># really relaying one            </span>
            <span class="n">prev_rcid</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">is_fst_protocol_msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">additional_info</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">)</span>
            <span class="n">additional_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">end_sender</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">end_rcvr</span><span class="o">=</span><span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;additional_info&#39;</span><span class="p">][</span><span class="s1">&#39;actual_rcvr&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rt_prop_return_trip_relay_fwd</span><span class="p">(</span><span class="n">is_fst_protocol_msg</span><span class="p">,</span> <span class="n">proposee</span><span class="p">,</span> <span class="n">cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">,</span> 
                                                <span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">rt_prop_answer_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span> 
                                                <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>
            
            <span class="c1"># After the second message has been processed, we can safely delete</span>
            <span class="c1"># information concerning the pending prop (the necessary information</span>
            <span class="c1"># will be stored elsewhere, as if the node was a simple relay)</span>
            <span class="k">if</span> <span class="s1">&#39;one_msg_processed_already&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;sent&#39;</span><span class="p">][(</span><span class="n">proposee</span><span class="p">,</span> <span class="n">cid</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;one_msg_processed_already&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    
    
    
    
    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Route proposals: Return trip, forward direction</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_handle_rt_prop_relay_fwd_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler of :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` messages</span>
<span class="sd">        </span>
<span class="sd">        This type of message is received by relays or  end-receiver of route</span>
<span class="sd">        proposals, or by the helper in an oriented comm initialisation.</span>
<span class="sd">        </span>
<span class="sd">        In the first case, each of the two related</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` can be processed</span>
<span class="sd">        independetly, and this function simply calls</span>
<span class="sd">        :meth:`._rt_prop_return_trip_relay_fwd`</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        In the second case and third case, the function defers the treatement of</span>
<span class="sd">        the :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` message to</span>
<span class="sd">        :meth:`._receiver_handle_rt_prop_relay_fwd_msg`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There are two mains cases when the node receives a rt prop relay fwd</span>
        <span class="c1"># message: either it is a simple relay, either it is the receiver. </span>
        <span class="n">prev_node</span> <span class="o">=</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">sent_by</span>
        <span class="n">prev_cid</span> <span class="o">=</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">cid</span>
        <span class="n">prev_rcid</span> <span class="o">=</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">rcid</span>
        <span class="n">is_fst_protocol_msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_answer&#39;</span><span class="p">]:</span>
            <span class="c1"># If the node is receiver AND it is the second rt prop relay fwd msg it</span>
            <span class="c1"># receives, then the below condition will be true.</span>
            <span class="n">is_receiver</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, try to handle the rt prop relay fwd msg as a relay. The</span>
            <span class="c1">#function returns ``True`` if the node is actually the receiver (and</span>
            <span class="c1">#it is the first rt prop relay fwd message that it sees</span>
            <span class="n">is_receiver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rt_prop_return_trip_relay_fwd</span><span class="p">(</span><span class="n">is_fst_protocol_msg</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">,</span>
                                                              <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span>
                                                              <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">)</span>
            
        
        <span class="c1"># If the node is the receiver, a different processing is applied</span>
        <span class="k">if</span> <span class="n">is_receiver</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_receiver_handle_rt_prop_relay_fwd_msg</span><span class="p">(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="p">)</span>
        
    
    <span class="k">def</span> <span class="nf">_rt_prop_return_trip_relay_fwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_fst_protocol_msg</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">additional_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Relays a route proposal answer on the way forward, from proposer to receiver</span>
<span class="sd">        </span>
<span class="sd">        This function is called either by: a node that itself received a</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` message, or by</span>
<span class="sd">        proposers that itself received a</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_ANSWER` message for a non-</span>
<span class="sd">        self-proposal. In the first case, the node can either be a simple relay</span>
<span class="sd">        (and must forward the</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` message), or the</span>
<span class="sd">        end-receiver (that must bounce back a</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_BWD` message).</span>
<span class="sd">        </span>
<span class="sd">        If the node is *not* the receiver, the role of this function is to</span>
<span class="sd">        process the ciphertexts involved in the route proposal (mainly by re-</span>
<span class="sd">        encrypting them, and by adding in its own temporary public key), and to</span>
<span class="sd">        forward the message. This function is meant to process</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` messages *one by</span>
<span class="sd">        one*. Recall that, for the same route proposal, 4 ciphertexts need to do</span>
<span class="sd">        the return trip from proposee to receiver, and thus two messages are</span>
<span class="sd">        necessary. The &quot;first protocol message&quot; is defined as the one carrying</span>
<span class="sd">        the encrypted dst**src value (and the encryted temporary public key). A</span>
<span class="sd">        node makes the distinction between the first and second protocol</span>
<span class="sd">        mesasge, because the later has a rcid different from the first, but</span>
<span class="sd">        deterministically bound to it, according to the definition of</span>
<span class="sd">        :meth:`apart.core.network.Network.get_related_rcid`.</span>
<span class="sd">        </span>
<span class="sd">        If the node is the receiver, this function return ``True``, whch has the</span>
<span class="sd">        effect of aborting the function early and coming back to</span>
<span class="sd">        :meth:`._handle_rt_prop_relay_fwd_msg`.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * is_fst_protocol_msg (bool): True if the</span>
<span class="sd">                                    :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` message is the</span>
<span class="sd">                                    one carrying the encrypted dst**src value</span>
<span class="sd">            * prev_node (int): the previous relay node (or the proposee, if this function was called by the proposer)</span>
<span class="sd">            * prev_cid (int): the cid with which the previous node sent its message </span>
<span class="sd">            * prev_rcid(int or None): the rcid with which the previous relay node sent its message, </span>
<span class="sd">                                    or None if this function is called by the proposer  </span>
<span class="sd">            * c1 (:class:`~apart.crypto.crypto.Ctxt`): the first ciphertext to relay (either dst**src or the encrypted result of the route length test)</span>
<span class="sd">            * c2 (:class:`~apart.crypto.crypto.Ctxt`): the second ciphertext to relay (either pk_tmp or the encrypted result of the route loop test)</span>
<span class="sd">            * additional_info (:obj:`dict` or None): the additional info to carry along the return trip. For purposes of the simualtion and measurements </span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            * bool or None: True if the node is the end-receiver of the route proposal </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First of all, check if a temporary storage used for forwarding the rt</span>
        <span class="c1"># prop relay fwd messages was already created. If so, that measn the</span>
        <span class="c1"># node is *not* the receiver, and that the first of the two rt prop</span>
        <span class="c1"># relay fwd message was already processed</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;fwd&#39;</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_relay&#39;</span><span class="p">]:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_relay&#39;</span><span class="p">][(</span><span class="s1">&#39;fwd&#39;</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)]</span>
            <span class="n">next_node</span> <span class="o">=</span>  <span class="n">info</span><span class="p">[</span><span class="s1">&#39;next_node&#39;</span><span class="p">]</span>
            <span class="n">next_cid</span> <span class="o">=</span>  <span class="n">info</span><span class="p">[</span><span class="s1">&#39;next_cid&#39;</span><span class="p">]</span>
            <span class="n">new_rcid</span> <span class="o">=</span>  <span class="n">info</span><span class="p">[</span><span class="s1">&#39;new_rcid&#39;</span><span class="p">]</span>
            <span class="n">cone</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;cone&#39;</span><span class="p">]</span>
            <span class="n">pk_tmp</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;pk_tmp&#39;</span><span class="p">]</span> 
            
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_relay&#39;</span><span class="p">][(</span><span class="s1">&#39;fwd&#39;</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the (unique) next hop on the route. This &quot;next hop&quot; will tell</span>
            <span class="c1"># if the node is a relay or the receiver</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">joint_lookup</span><span class="p">(</span><span class="n">PRT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">],</span> <span class="n">join_on</span><span class="o">=</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">,</span> <span class="n">PRT</span><span class="o">.</span><span class="n">RT_ROWID</span><span class="p">],</span> <span class="n">constraints</span><span class="o">=</span><span class="p">{</span><span class="n">PRT</span><span class="o">.</span><span class="n">PREV_NODE</span><span class="p">:</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">PRT</span><span class="o">.</span><span class="n">PREV_CID</span><span class="p">:</span> <span class="n">prev_cid</span><span class="p">})</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Protocol error: node </span><span class="si">{}</span><span class="s2"> must relay a </span><span class="si">{}</span><span class="s2"> message, but can not seem to find a unique next hop (rows returned: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_RELAY_FWD</span><span class="p">),</span> <span class="p">[[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">])</span>
            
            <span class="c1"># A null next hop indicates that the end of the route is reached,</span>
            <span class="c1"># i.e. the node is not a realy, but a receiver</span>
            <span class="k">if</span> <span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">]</span> <span class="o">==</span> <span class="n">F_NULL</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The node is a simple relay, and this is the first out of two</span>
                <span class="c1"># rt prop relay fwd messages</span>
                <span class="n">next_node</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">]</span>
                <span class="n">next_cid</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">]</span>
                <span class="n">new_rcid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">get_next_rcid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">next_node</span><span class="p">)</span>
                <span class="n">cone</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">]</span>
                <span class="p">(</span><span class="n">pk_tmp</span><span class="p">,</span> <span class="n">sk_tmp</span><span class="p">)</span> <span class="o">=</span> <span class="n">Elgamal_keygen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">secparam</span><span class="p">)</span>
                
                <span class="c1"># Store information for the *second* rt prop relay fwd message</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_relay&#39;</span><span class="p">][(</span><span class="s1">&#39;fwd&#39;</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)]</span> <span class="o">=</span> \
                                <span class="p">{</span><span class="s1">&#39;next_node&#39;</span><span class="p">:</span> <span class="n">next_node</span><span class="p">,</span> <span class="s1">&#39;next_cid&#39;</span><span class="p">:</span> <span class="n">next_cid</span><span class="p">,</span> <span class="s1">&#39;new_rcid&#39;</span><span class="p">:</span> <span class="n">new_rcid</span><span class="p">,</span>
                                 <span class="s1">&#39;cone&#39;</span><span class="p">:</span> <span class="n">cone</span><span class="p">,</span> <span class="s1">&#39;pk_tmp&#39;</span><span class="p">:</span> <span class="n">pk_tmp</span><span class="p">}</span>
                
                <span class="c1"># Store information needed to later relay the two rt prop relay</span>
                <span class="c1"># bwd messages</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_relay&#39;</span><span class="p">][(</span><span class="s1">&#39;bwd&#39;</span><span class="p">,</span> <span class="n">next_node</span><span class="p">,</span> <span class="n">next_cid</span><span class="p">,</span> <span class="n">new_rcid</span><span class="p">)]</span> <span class="o">=</span> \
                        <span class="p">{</span><span class="s1">&#39;node_to_proposee&#39;</span><span class="p">:</span> <span class="n">prev_node</span><span class="p">,</span> <span class="s1">&#39;cid_to_proposee&#39;</span><span class="p">:</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="s1">&#39;rcid_to_proposee&#39;</span><span class="p">:</span> <span class="n">prev_rcid</span><span class="p">,</span>
                        <span class="s1">&#39;cone&#39;</span><span class="p">:</span> <span class="n">cone</span><span class="p">,</span><span class="s1">&#39;sk_tmp&#39;</span><span class="p">:</span> <span class="n">sk_tmp</span><span class="p">}</span>             
        
        <span class="c1"># The value of the rcid depends on whether it is the first or second</span>
        <span class="c1">#message (according to the protocol, not the order of receiving).</span>
        <span class="c1">#Likewise, the processing of ciphertext differs slighlty</span>
        <span class="k">if</span> <span class="n">is_fst_protocol_msg</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">Elgamal_key_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">c1</span><span class="p">))</span> 
            <span class="c1"># The second ciphertext of the first message contains the</span>
            <span class="c1"># (accumulation of) temporary public key(s). The node must thus</span>
            <span class="c1"># multiply in its own pk. </span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">Elgamal_key_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">Elgamal_plain_mult</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">pk_tmp</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">Elgamal_key_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">c1</span><span class="p">))</span> 
            <span class="n">c2</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">Elgamal_key_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span>
        
        
        <span class="c1"># Craft and send the message</span>
        <span class="n">new_rt_prop_relay_fwd_msg</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">next_node</span><span class="p">,</span> 
                                              <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                                              <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_RELAY_FWD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">next_cid</span><span class="p">,</span> <span class="n">rcid</span><span class="o">=</span><span class="n">new_rcid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_fst_protocol_msg</span> <span class="k">else</span> <span class="mi">2</span><span class="p">),</span>
                                              <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">new_rt_prop_relay_fwd_msg</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="kc">False</span>
    
    
    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Route proposals: receiver, and bounce back of return trip</span>
    <span class="c1"># ==========================================================================                    </span>
    <span class="k">def</span> <span class="nf">_receiver_handle_rt_prop_relay_fwd_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler of :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` messages, specifically for receivers of route proposals, or for helpers in a oriented communication initialisation</span>
<span class="sd">        </span>
<span class="sd">        This function is mainly meant to model the behavior of the end-receiver</span>
<span class="sd">        in a route proposal. But, because relay rt prop fwd messages are also</span>
<span class="sd">        used during oriented communication initialisation, this function also</span>
<span class="sd">        takes into account that possibility.</span>
<span class="sd">        </span>
<span class="sd">        If the node is a receiver of route proposal, the function waits for both</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` messages to be</span>
<span class="sd">        received, processes the ciphertexts, and sends back</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_BWD` messages</span>
<span class="sd">            </span>
<span class="sd">        If the node is a helper of oriented communications, it deffers the</span>
<span class="sd">        processing to :meth:`._helper_process_ocom_init_msg`.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * prev_node (int): the previous relay node</span>
<span class="sd">            * prev_cid (int): the cid with which the previous node sent its message </span>
<span class="sd">            * prev_rcid(int or None): the rcid with which the previous relay node sent its message</span>
<span class="sd">            * rt_prop_relay_fwd_msg (:obj:`~apart.core.messages.LinkMsg`): the :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` message received</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialise the temporary storage</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_answer&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_answer&#39;</span><span class="p">][(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Boldly try to see if the message is part of an oriented communication</span>
        <span class="c1"># initialisation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_answer&#39;</span><span class="p">][(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)]</span> <span class="o">==</span> <span class="s1">&#39;ocom&#39;</span><span class="p">:</span>
            <span class="n">is_ocom</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">inner_header</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_answer&#39;</span><span class="p">][(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inner_header</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">)</span>
                <span class="n">is_ocom</span> <span class="o">=</span> <span class="n">inner_header</span><span class="o">.</span><span class="n">flag</span> <span class="ow">is</span> <span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_INIT</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_answer&#39;</span><span class="p">][(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;ocom&#39;</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">is_ocom</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">is_ocom</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_helper_process_ocom_init_msg</span><span class="p">(</span><span class="n">rt_prop_relay_fwd_msg</span><span class="p">,</span> <span class="n">inner_header</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="c1"># If we arrive here, that means the node is a receiver in a route proposal</span>
        

        
        <span class="n">pending_rt_prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_answer&#39;</span><span class="p">][(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)]</span>
        <span class="n">is_fst_protocol_msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">is_fst_protocol_msg</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cpseudo&#39;</span><span class="p">:</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="s1">&#39;cpktmp&#39;</span><span class="p">:</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;chopcount&#39;</span><span class="p">:</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="s1">&#39;cwhoisontheroute&#39;</span><span class="p">:</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">}</span>
        <span class="n">pending_rt_prop</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="s1">&#39;cpseudo&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span> <span class="ow">and</span> <span class="s1">&#39;chopcount&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span><span class="p">:</span>
            <span class="c1"># When both prop relay fwd messages are received, the receiver can</span>
            <span class="c1"># make an answer, and send back a rt prop relay bwd message</span>
            <span class="n">ctxts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receiver_process_rt_prop</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">pending_rt_prop</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span> <span class="k">for</span> <span class="n">cname</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cpseudo&#39;</span><span class="p">,</span> <span class="s1">&#39;cpktmp&#39;</span><span class="p">,</span> <span class="s1">&#39;chopcount&#39;</span><span class="p">,</span> <span class="s1">&#39;cwhoisontheroute&#39;</span><span class="p">]])</span>
            <span class="n">additional_info</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">)</span>
            <span class="n">additional_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">end_sender</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">end_rcvr</span><span class="o">=</span><span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;end_sender&#39;</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_rt_prop_return_trip_relay_bwd</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">sent_by</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">,</span> 
                                                <span class="n">ctxts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ctxts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rt_prop_return_trip_relay_bwd</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">sent_by</span><span class="p">,</span> <span class="n">rt_prop_relay_fwd_msg</span><span class="o">.</span><span class="n">cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">,</span> 
                                                <span class="n">ctxts</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ctxts</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>
            
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_answer&#39;</span><span class="p">][(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">,</span> <span class="n">prev_rcid</span><span class="p">)]</span>
            

                                                                 
        
    <span class="k">def</span> <span class="nf">_receiver_process_rt_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cpseudo</span><span class="p">,</span> <span class="n">cpktmp</span><span class="p">,</span> <span class="n">caccept_hopcount</span><span class="p">,</span> <span class="n">caccept_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Processes the four ciphertexts crafted by the proposee, to compute the pseudonym and the yes/no answer on the route acceptation</span>
<span class="sd">        </span>
<span class="sd">        Al lthe ciphertexts given in argument are encrypted under the receiver&#39;s</span>
<span class="sd">        secret key (uniquely), and all the output ciphertexts are encrypted</span>
<span class="sd">        under the product of temporary secret key (that is contained in ``cpktmp``.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * cpseudo (:class:`~apart.crypto.crypto.Ctxt`): the dst**src value </span>
<span class="sd">            * cpktmp (:class:`~apart.crypto.crypto.Ctxt`): the product of temporary public key, </span>
<span class="sd">                                    accumulated during the forwarding from proposer to receiver</span>
<span class="sd">            * caccept_hopcount (:class:`~apart.crypto.crypto.Ctxt`): the hop count test, g**(lmax-l) </span>
<span class="sd">            * caccept_loop (:class:`~apart.crypto.crypto.Ctxt`): the loop test, g**0/1</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            * :class:`~apart.crypto.crypto.Ctxt`: the pseudonym, encrypted under pktmp</span>
<span class="sd">            * :class:`~apart.crypto.crypto.Ctxt`: the value one, encrypted under pktmp</span>
<span class="sd">            * :class:`~apart.crypto.crypto.Ctxt`: the yes/no answer on route acceptance, encrypted under pktmp</span>
<span class="sd">            * :class:`~apart.crypto.crypto.Ctxt`: the value one, encrypted under pktmp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Log the_rt prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_rt_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;answered_as_receiver&#39;</span><span class="p">)</span>
        
        <span class="c1"># Here, the receiver must simply process the ciphertexts. </span>
        <span class="c1"># The function returns a set of ciphertexts to send back accordingly, but does not actually sends any messages</span>
        <span class="n">pseudo</span> <span class="o">=</span> <span class="n">SHA3_hash</span><span class="p">(</span><span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">cpseudo</span><span class="p">))</span>
        <span class="n">pktmp</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">cpktmp</span><span class="p">)</span>
        
        <span class="n">accept_hopcount</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">caccept_hopcount</span><span class="p">)</span>
        <span class="n">acceptrt</span> <span class="o">=</span> <span class="n">accept_hopcount</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GROUP_G</span><span class="o">**</span><span class="n">i</span> <span class="o">%</span> <span class="n">GROUP_P</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">range1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">rtprop_policy_max_hop_count</span><span class="p">)]</span>
        <span class="n">acceptrt</span> <span class="o">=</span> <span class="n">acceptrt</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">caccept_loop</span><span class="p">)</span>
        
        <span class="n">cpseudo</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="n">pktmp</span><span class="p">,</span> <span class="n">pseudo</span><span class="p">)</span>
        <span class="n">cone</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="n">pktmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cacceptrt</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="n">pktmp</span><span class="p">,</span> <span class="n">acceptrt</span><span class="p">)</span>
        <span class="n">other_cone</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="n">pktmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">cpseudo</span><span class="p">,</span> <span class="n">cone</span><span class="p">,</span> <span class="n">cacceptrt</span><span class="p">,</span> <span class="n">other_cone</span>
    

    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Route proposals: Return trip, backward direction</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_handle_rt_prop_relay_bwd_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler of :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_BWD` messages</span>
<span class="sd">        </span>
<span class="sd">        It is very similar to :meth:`._handle_rt_prop_relay_fwd_msg`, but for</span>
<span class="sd">        the backward direction of the return trip. This type of message is</span>
<span class="sd">        received by relays or the proposer of a route proposals, or by the end-</span>
<span class="sd">        sender in an oriented comm initialisation.</span>
<span class="sd">        </span>
<span class="sd">        In the first case, each of the two related</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_BWD` can be processed</span>
<span class="sd">        independetly, and this function simply calls</span>
<span class="sd">        :meth:`._rt_prop_return_trip_relay_bwd`.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        In the second case, the function defers the treatement of</span>
<span class="sd">        the :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_VWD` message to</span>
<span class="sd">        :meth:`._proposer_handle_rt_prop_relay_bwd_msg`.</span>
<span class="sd">        </span>
<span class="sd">        In the third case, if the node is actually an end-sender in an oriented </span>
<span class="sd">        communication, the function defers the processing to </span>
<span class="sd">        :meth:`._sender_ocom_init_finalise`</span>
<span class="sd">        </span>
<span class="sd">        In any case, the function also manages the deletion of the temporary</span>
<span class="sd">        information on the route proposal when it is no longer needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There are two mains cases when the node receives a rt prop relay bwd</span>
        <span class="c1"># message: either it is a simple relay, either it is the original</span>
        <span class="c1"># proposer.</span>
        <span class="n">node_to_receiver</span> <span class="o">=</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">sent_by</span>
        <span class="n">cid_to_receiver</span> <span class="o">=</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">cid</span>
        <span class="n">rcid_to_receiver</span> <span class="o">=</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">rcid</span>
        <span class="n">is_fst_protocol_msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># First of all, test if this message is part of an oriented </span>
        <span class="c1"># communication initalisation</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ocomid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">][(</span><span class="s1">&#39;rt_prop_relay_bwd_shortcut&#39;</span><span class="p">,</span> <span class="n">node_to_receiver</span><span class="p">,</span> <span class="n">cid_to_receiver</span><span class="p">,</span> <span class="n">rcid_to_receiver</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">ocomid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ocomid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sender_ocom_init_finalise</span><span class="p">(</span><span class="n">ocomid</span><span class="p">,</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="p">)</span>
            <span class="k">return</span>
            
        <span class="c1"># If the node is not the sender in an oriented communication, </span>
        <span class="c1"># it must be that it is a relay or proposer in a route proposal</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s1">&#39;bwd&#39;</span><span class="p">,</span> <span class="n">node_to_receiver</span><span class="p">,</span> <span class="n">cid_to_receiver</span><span class="p">,</span> <span class="n">rcid_to_receiver</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_relay&#39;</span><span class="p">]</span>
        <span class="n">pending_rt_prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_relay&#39;</span><span class="p">][(</span><span class="s1">&#39;bwd&#39;</span><span class="p">,</span> <span class="n">node_to_receiver</span><span class="p">,</span> <span class="n">cid_to_receiver</span><span class="p">,</span> <span class="n">rcid_to_receiver</span><span class="p">)]</span>

        
        <span class="k">if</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;rcid_to_proposee&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the node is the proposer, call the function specific to this case</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proposer_handle_rt_prop_relay_bwd_msg</span><span class="p">(</span><span class="n">pending_rt_prop</span><span class="p">,</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, try to handle the rt prop relay bwd msg as a relay. </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rt_prop_return_trip_relay_bwd</span><span class="p">(</span><span class="n">is_fst_protocol_msg</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;node_to_proposee&#39;</span><span class="p">],</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cid_to_proposee&#39;</span><span class="p">],</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;rcid_to_proposee&#39;</span><span class="p">],</span> 
                                                <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;sk_tmp&#39;</span><span class="p">],</span>
                                                <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">)</span>
        
        <span class="c1"># Manage the deletion of the temporary storage of the route proposal</span>
        <span class="c1"># information</span>
        <span class="k">if</span> <span class="s1">&#39;one_msg_processed_already&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span><span class="p">:</span>
            <span class="c1"># If the node ahs finished relaying the two related rt prop relay</span>
            <span class="c1"># bwd msgs, delete the pending rt prop</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_relay&#39;</span><span class="p">][(</span><span class="s1">&#39;bwd&#39;</span><span class="p">,</span> <span class="n">node_to_receiver</span><span class="p">,</span> <span class="n">cid_to_receiver</span><span class="p">,</span> <span class="n">rcid_to_receiver</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;one_msg_processed_already&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="c1"># Below function used by : relays upon rt prop relay bwd msg, receivers upon</span>
    <span class="c1">#rt prop relay fwd msg</span>
    <span class="k">def</span> <span class="nf">_rt_prop_return_trip_relay_bwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_fst_protocol_msg</span><span class="p">,</span> <span class="n">node_to_proposee</span><span class="p">,</span> <span class="n">cid_to_proposee</span><span class="p">,</span> <span class="n">rcid_to_proposee</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">sk_tmp</span><span class="p">,</span> <span class="n">additional_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Relays a route proposal answer on the way back, from receiver to proposer</span>
<span class="sd">        </span>
<span class="sd">        This function is the alter ego of</span>
<span class="sd">        :meth:`._rt_prop_return_trip_relay_fwd`, but slightly simpler.</span>
<span class="sd">        </span>
<span class="sd">        This function is called either by: a node that itself received a</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_BWD` message, or by a</span>
<span class="sd">        receiver that received a</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD` message  and wants</span>
<span class="sd">        to bounce back the ciphertexts on the return trip.</span>
<span class="sd">        </span>
<span class="sd">        Note that the tuple (node_to_proposee, cid_to_proposee,</span>
<span class="sd">        rcid_to_proposee) is actually used to retrive the temporary information</span>
<span class="sd">        stored on the node during the relaying forward of the return trip. This</span>
<span class="sd">        temporary information mainly says where and how to relay back to the proposer.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * is_fst_protocol_msg (bool): True if the</span>
<span class="sd">                                    :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_BWD` message is the</span>
<span class="sd">                                    one carrying the encrypted pseudonym</span>
<span class="sd">            * node_to_proposee (int): the next relay node, towards the proposee and proposer</span>
<span class="sd">            * cid_to_proposee (int): the next cid to use </span>
<span class="sd">            * rcid_to_proposee(int or None): the next rcid to use</span>
<span class="sd">            * c1 (:class:`~apart.crypto.crypto.Ctxt`): the first ciphertext to relay (either the pseudonym0 </span>
<span class="sd">                                        or the encrypted yes/no answer on the route acceptance)</span>
<span class="sd">            * c2 (:class:`~apart.crypto.crypto.Ctxt`): the second ciphertext to relay (always an encryption of one)</span>
<span class="sd">            * additional_info (:obj:`dict` or None): the additional info to carry along the return trip. For purposes of the simualtion and measurements </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">sk_tmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># sk_tmp is None when this fucntion is called by the receiver</span>
            <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rt_prop_return_trip_bwd_partial_dec</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">sk_tmp</span><span class="p">)</span>
        
        <span class="c1"># Craft and send the rt prop relay bwd msg </span>
        <span class="n">new_rt_prop_relay_bwd_msg</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">node_to_proposee</span><span class="p">,</span>
                                          <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                                          <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_RELAY_BWD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">cid_to_proposee</span><span class="p">,</span> <span class="n">rcid</span><span class="o">=</span><span class="n">rcid_to_proposee</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_fst_protocol_msg</span> <span class="k">else</span> <span class="mi">2</span><span class="p">),</span>
                                          <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">node_to_proposee</span><span class="p">,</span> <span class="n">new_rt_prop_relay_bwd_msg</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">_rt_prop_return_trip_bwd_partial_dec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">sk_tmp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function for relay nodes on the way backward of the return trip to cancell out their temporary secret key&quot;&quot;&quot;</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">Reenc_one</span><span class="p">(</span><span class="n">Elgamal_key_div</span><span class="p">(</span><span class="n">sk_tmp</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">Elgamal_key_div</span><span class="p">(</span><span class="n">sk_tmp</span><span class="p">,</span> <span class="n">c1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span>
    
    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Route proposals: Proposer, end of 3rd step</span>
    <span class="c1"># (note: in self-proposals, 2nd and 3rd step are made in one go)</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_proposer_handle_rt_prop_relay_bwd_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">,</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler of :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_BWD` messages, specifically for proposers of route proposals</span>
<span class="sd">        </span>
<span class="sd">        This function is mainly meant to model the behavior of the proposer in a</span>
<span class="sd">        *relayed* route proposal, upon return of the answer from the receiver.</span>
<span class="sd">       </span>
<span class="sd">        </span>
<span class="sd">        Here, each</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_BWD` message can be</span>
<span class="sd">        processed independently. The proposer only needs to &quot;transform&quot; them into </span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RTPROP_FINAL` messages.</span>
<span class="sd">        </span>

<span class="sd">        Arguments:</span>
<span class="sd">            * pending_rt_prop (:obj:`dict`): information on the route proposal</span>
<span class="sd">            * rt_prop_relay_bwd_msg (:obj:`~apart.core.messages.LinkMsg`): the :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_BWD` message received</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
       
        <span class="c1"># If the node is a proposer of a route proposal, it must &quot;transform&quot; the</span>
        <span class="c1"># rt pro prelay bwd msgs into rt prop final ones, and send them back. Do</span>
        <span class="c1"># not forget to partially decrypt the ciphertexts also</span>
        <span class="n">is_fst_protocol_msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rt_prop_return_trip_bwd_partial_dec</span><span class="p">(</span><span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span>  <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;sk_tmp&#39;</span><span class="p">])</span>
<span class="c1">#         pending_sent_rt_prop = self._pending_rt_props[&#39;sent&#39;][(pending_rt_prop[&#39;node_to_proposee&#39;], pending_rt_prop[&#39;cid_to_proposee&#39;])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proposer_send_rt_prop_final_msg</span><span class="p">(</span><span class="n">is_fst_protocol_msg</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;node_to_proposee&#39;</span><span class="p">],</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cid_to_proposee&#39;</span><span class="p">],</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_proposer_send_rt_prop_final_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_fst_protocol_msg</span><span class="p">,</span> <span class="n">proposee</span><span class="p">,</span> <span class="n">cid</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Craft and sends the :attr:`~apart.core.messages.MsgFlag.RTPROP_FINAL` messages to the proposee</span>
<span class="sd">        </span>
<span class="sd">        Called by the proposer, this function handles the two messages part of</span>
<span class="sd">        the route proposal independently form each other</span>
<span class="sd">        </span>
<span class="sd">        Arguments: </span>
<span class="sd">            * pending_rt_prop (:obj:`dict`): temporary information on the route proposal</span>
<span class="sd">            * is_fst_protocol_msg (bool): True if the message is carrying the encrypted pseudonym</span>
<span class="sd">             * c1 (:class:`~apart.crypto.crypto.Ctxt`): the first ciphertext to relay (either the pseudonym0 </span>
<span class="sd">                                        or the encrypted yes/no answer on the route acceptance)</span>
<span class="sd">            * c2 (:class:`~apart.crypto.crypto.Ctxt`): the second ciphertext to relay (always an encryption of one)</span>
<span class="sd">        &quot;&quot;&quot;</span> 
                     
        <span class="c1"># Craft a rt prop final messages, and place it in the right pool</span>
        <span class="n">rt_prop_final_msg</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">proposee</span><span class="p">,</span> 
                                     <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_FINAL</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">cid</span><span class="p">,</span>  
                                     <span class="n">seq_index</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_fst_protocol_msg</span> <span class="k">else</span> <span class="mi">2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">proposee</span><span class="p">,</span> <span class="n">rt_prop_final_msg</span><span class="p">)</span>
        

    
    

    
    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Route proposals: Proposee, 2nd and FINAL step</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_handle_rt_prop_final_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rt_prop_final_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler of :attr:`~apart.core.messages.MsgFlag.RTPROP_FINAL` messages  (received by proposees)</span>
<span class="sd">        </span>
<span class="sd">        This function merely waits for the two messages part of the route</span>
<span class="sd">        proposal to arrive, and calls :meth:`._proposee_process_rt_prop_final`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Similarly to rt prop and rt prop answer messages, a node expects two</span>
        <span class="c1"># rt prop final answer mesasges, in any order</span>
        <span class="n">prev_cid</span> <span class="o">=</span> <span class="n">rt_prop_final_msg</span><span class="o">.</span><span class="n">cid</span>
        <span class="n">prev_node</span> <span class="o">=</span> <span class="n">rt_prop_final_msg</span><span class="o">.</span><span class="n">sent_by</span>
        <span class="n">is_fst_protocol_msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rt_prop_final_msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;rcvd&#39;</span><span class="p">]</span>
        <span class="n">pending_rt_prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;rcvd&#39;</span><span class="p">][(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">prev_cid</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">is_fst_protocol_msg</span><span class="p">:</span>
            <span class="c1"># This is the first rt prop final message</span>
            <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cpseudo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt_prop_final_msg</span><span class="o">.</span><span class="n">c1</span>
            <span class="k">if</span> <span class="s1">&#39;cacceptrt&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_proposee_process_rt_prop_final</span><span class="p">(</span><span class="n">pending_rt_prop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is the second rt prop final message</span>
            <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cacceptrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt_prop_final_msg</span><span class="o">.</span><span class="n">c1</span>
            <span class="k">if</span> <span class="s1">&#39;cpseudo&#39;</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_proposee_process_rt_prop_final</span><span class="p">(</span><span class="n">pending_rt_prop</span><span class="p">)</span>
        
   
    <span class="k">def</span> <span class="nf">_proposee_process_rt_prop_final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">):</span>     
        <span class="sd">&quot;&quot;&quot;Final processing of the route proposal by the proposee, and decision to accept the route or not</span>
<span class="sd">        </span>
<span class="sd">        The node, as a proposee, first sees it if accepts the route and if it</span>
<span class="sd">        must re-propose it or not (by calling</span>
<span class="sd">        :meth:`__route_proposal_policy_final_decision`). If not, it stops. If</span>
<span class="sd">        so, it inserts a new routing table entry, and sees if it reproposes it</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * pending_rt_prop (:obj:`dict`): temporary stored information on the</span>
<span class="sd">                                    route proposal. Contains in particular the (encrypted) pseudonym</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, get the pseudo and the yes/no answer stating that the node</span>
        <span class="c1"># accepts the route or not</span>
        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">sk_tmp</span><span class="p">)</span> <span class="o">=</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;tmpkeypair&#39;</span><span class="p">]</span>
        <span class="n">pseudo</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="n">sk_tmp</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cpseudo&#39;</span><span class="p">])</span>
        <span class="n">acceptrt</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="n">sk_tmp</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cacceptrt&#39;</span><span class="p">])</span>
        <span class="n">cid</span> <span class="o">=</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cid&#39;</span><span class="p">]</span>
        
        <span class="c1"># Run the route proposal policy</span>
        <span class="n">accept</span><span class="p">,</span> <span class="n">reprop</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_route_proposal_policy_final_decision</span><span class="p">(</span><span class="n">pseudo</span><span class="p">,</span> <span class="n">acceptrt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">accept</span> <span class="ow">and</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">RtPolicyReason</span><span class="o">.</span><span class="n">REFUSE_ITSELF</span> <span class="ow">or</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;additional_info&#39;</span><span class="p">][</span><span class="s1">&#39;actual_rcvr&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">accept</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;additional_info&#39;</span><span class="p">][</span><span class="s1">&#39;actual_length&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">rtprop_policy_max_hop_count</span> <span class="ow">and</span> <span class="n">reason</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">RtPolicyReason</span><span class="o">.</span><span class="n">ACCEPT_FIRST_KNOWN_ROUTE</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">accept</span> <span class="ow">or</span> <span class="s2">&quot; </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cwhoisontheroute&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> is accepting a route towards node </span><span class="si">{}</span><span class="s2"> at round </span><span class="si">{}</span><span class="s2"> (reason : </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;additional_info&#39;</span><span class="p">][</span><span class="s1">&#39;actual_rcvr&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">,</span> <span class="n">reason</span><span class="p">))</span>
            
            <span class="c1"># Insert rt entry</span>
            <span class="n">rt_entry</span> <span class="o">=</span> <span class="p">{</span><span class="n">RT</span><span class="o">.</span><span class="n">PSEUDO</span><span class="p">:</span> <span class="n">pseudo</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">:</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cone&#39;</span><span class="p">],</span> 
                        <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">:</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;proposer&#39;</span><span class="p">],</span>  <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">:</span> <span class="n">cid</span><span class="p">,</span> 
                        <span class="n">RT</span><span class="o">.</span><span class="n">TIMESTAMP</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">REPROPOSED</span><span class="p">:</span> <span class="p">(</span><span class="n">reprop</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">),</span>
                        <span class="n">RT</span><span class="o">.</span><span class="n">IN_USE</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">:</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;additional_info&#39;</span><span class="p">][</span><span class="s1">&#39;actual_rcvr&#39;</span><span class="p">],</span>
                        <span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_LENGTH</span><span class="p">:</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;additional_info&#39;</span><span class="p">][</span><span class="s1">&#39;actual_length&#39;</span><span class="p">]}</span>
            <span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">insert_entry</span><span class="p">(</span><span class="o">**</span><span class="n">rt_entry</span><span class="p">)</span>
            
            <span class="c1"># If it is the *first* learned route towards the pseudo, do not</span>
            <span class="c1"># relay it straight away (unless we are at the beginning of the</span>
            <span class="c1"># network, in which case there is no choice: nodes only have routes</span>
            <span class="c1"># towards their neighbors)</span>
            <span class="k">if</span> <span class="n">reprop</span> <span class="o">==</span> <span class="s1">&#39;later&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">lookup</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_repropose&#39;</span><span class="p">][</span><span class="n">pseudo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_delayed_relay_rt_prop</span><span class="p">(</span><span class="n">rt_entry</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">batching_t_interval</span><span class="o">*</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">350</span><span class="p">))))</span>
            <span class="k">elif</span> <span class="n">reprop</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_relay_rt_prop</span><span class="p">(</span><span class="n">rt_entry</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> is refusing a route towards node </span><span class="si">{}</span><span class="s2"> at round </span><span class="si">{}</span><span class="s2"> (reason : </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;additional_info&#39;</span><span class="p">][</span><span class="s1">&#39;actual_rcvr&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">,</span> <span class="n">reason</span><span class="p">))</span>
        
        
        <span class="c1"># Log the_rt prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_rt_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">nb_rounds_to_complete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="o">-</span><span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;additional_info&#39;</span><span class="p">][</span><span class="s1">&#39;round_rt_prop_started&#39;</span><span class="p">])</span>
        
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;rcvd&#39;</span><span class="p">][(</span><span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;proposer&#39;</span><span class="p">],</span> <span class="n">cid</span><span class="p">)]</span>
        
    <span class="k">def</span> <span class="nf">_route_proposal_policy_final_decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pseudo</span><span class="p">,</span> <span class="n">acceptrt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of the route proposal policy: returns booleans indicating if a proposee must accept a route, and possibly re-propose it</span>
<span class="sd">        </span>
<span class="sd">        Depending on various critera, such as route length, number of routes</span>
<span class="sd">        already known, and so on, the route may be accepted or not. And if</span>
<span class="sd">        accepted, it may or may not be re-proposed by the node.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * pseudo (int): the pseudonym of the receiver of the route to accept (or refuse)</span>
<span class="sd">            * acceptrt (bool): the yes/no answer computed jointly by the</span>
<span class="sd">                    proposee and receiver, that depends on the length of the</span>
<span class="sd">                    route and whether the node is already on the route or not.</span>
<span class="sd">                    If ``acceprt is False``, the route will automatically</span>
<span class="sd">                    refused</span>
<span class="sd">        Returns:</span>
<span class="sd">            * (bool): True if the route is accepted</span>
<span class="sd">            * (bool): True if the route must be re-proposed</span>
<span class="sd">            * (str): The reason of acceptation or refusal of the route</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pseudo</span> <span class="o">==</span> <span class="n">SHA3_hash</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src</span><span class="p">,</span> <span class="n">GROUP_P</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">RtPolicyReason</span><span class="o">.</span><span class="n">REFUSE_ITSELF</span><span class="p">)</span> 
        

        <span class="c1"># Get information on the routes already known towards the pseudonym</span>
        <span class="n">routes_to_pseudo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">TIMESTAMP</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">REPROPOSED</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">IN_USE</span><span class="p">],</span> <span class="n">constraints</span><span class="o">=</span><span class="p">{</span><span class="n">RT</span><span class="o">.</span><span class="n">PSEUDO</span><span class="p">:</span> <span class="n">pseudo</span><span class="p">})</span>
        

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">routes_to_pseudo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If the node learns about the receiver for the first time, it</span>
            <span class="c1"># accepts straight away in **any** case. But mark to relay the</span>
            <span class="c1"># proposition &quot;later&quot;, i.e. in a delayed fashion</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;later&#39;</span><span class="p">,</span> <span class="n">RtPolicyReason</span><span class="o">.</span><span class="n">ACCEPT_FIRST_KNOWN_ROUTE</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">acceptrt</span><span class="p">:</span> 
            <span class="c1"># If the encrypted decision (on hop count and loops) says no,</span>
            <span class="c1"># then refuse the route</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">RtPolicyReason</span><span class="o">.</span><span class="n">REFUSE_ENC_DEC</span><span class="p">)</span>
<span class="c1">#         elif sum(r[RT.IN_USE] for r in routes_to_pseudo) == self._net.params.rtprop_policy_max_routes:</span>
<span class="c1">#             return (False, False, RtPolicyReason.REFUSE_TOO_MANY_ROUTES_NO_REPLACEMENT)</span>
<span class="c1">#         else:</span>
<span class="c1">#             reason = RtPolicyReason.ACCEPT_REACCEPT_NO_REPLACEMENT</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">rtprop_policy_p_reaccept</span><span class="p">):</span>
            <span class="c1"># Randomly refuse the route, because the node already has &gt;= 1</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">RtPolicyReason</span><span class="o">.</span><span class="n">REFUSE_REACCEPT</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Else, see if the new route is going to replace an existing one</span>
<span class="c1">#             if len(routes_to_pseudo) &lt;= self._net.params.rtprop_policy_max_routes:</span>
<span class="c1">#                 effective_p_replace = self._net.params.rtprop_policy_p_replace</span>
<span class="c1">#             else:</span>
            <span class="n">effective_p_replace</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">rtprop_policy_p_replace</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">routes_to_pseudo</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">rtprop_policy_max_routes</span><span class="p">))</span>
            <span class="n">replace</span> <span class="o">=</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">effective_p_replace</span><span class="p">)</span><span class="c1">#self._net.params.rtprop_policy_p_replace)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">replace</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">IN_USE</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">routes_to_pseudo</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">rtprop_policy_max_routes</span><span class="p">:</span>
                <span class="c1"># If no replacement, AND we hit the maximum number of routes </span>
                <span class="c1"># in use, refuse</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">RtPolicyReason</span><span class="o">.</span><span class="n">REFUSE_TOO_MANY_ROUTES_NO_REPLACEMENT</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">replace</span><span class="p">:</span>
                <span class="c1"># If no replacement, but the maximum number of routes is not </span>
                <span class="c1"># reached, accept</span>
                <span class="n">reason</span> <span class="o">=</span> <span class="n">RtPolicyReason</span><span class="o">.</span><span class="n">ACCEPT_REACCEPT_NO_REPLACEMENT</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If remplacement, find and flag the oldest existing rt entry </span>
                <span class="c1"># as &quot;unused&quot;, meaning that it</span>
                <span class="c1"># is not used by the node for *sending*, but it is kept for</span>
                <span class="c1"># relaying (otherwise, routes break) </span>
                <span class="n">replaced_entry</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">routes_to_pseudo</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">IN_USE</span><span class="p">]),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">TIMESTAMP</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">update_entries</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="p">{</span><span class="n">RT</span><span class="o">.</span><span class="n">IN_USE</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span> <span class="n">constraints</span><span class="o">=</span><span class="p">{</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">:</span> <span class="n">replaced_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">]})</span>
                <span class="n">reason</span> <span class="o">=</span> <span class="n">RtPolicyReason</span><span class="o">.</span><span class="n">ACCEPT_REACCEPT_REPLACEMENT</span>
                 
                
        
        <span class="c1"># If the function arrives here, that means the route is accepted. We now</span>
        <span class="c1"># decide if the node must relay the proposition or not. Basically: yes </span>
        <span class="c1"># if and only if the node never proposed this pseudonym            </span>
        <span class="n">receiver_already_proposed</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">REPROPOSED</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">routes_to_pseudo</span><span class="p">)</span>
        <span class="n">relay_prop</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">receiver_already_proposed</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">relay_prop</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
            
    <span class="k">def</span> <span class="nf">_relay_rt_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rt_entry</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called by a proposee to relay a route proposal</span>
<span class="sd">        </span>
<span class="sd">        If, according to the route proposal policy (see</span>
<span class="sd">        :meth:`._route_proposal_policy_final_decision`), a proposee must relay</span>
<span class="sd">        the route it just learned, this function makes some preparation before</span>
<span class="sd">        calling :meth:`._propose_route`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lower the flag stipulating that the node must re-propose a route </span>
        <span class="c1"># towards the pseudonym being proposed (mechanisms that is here to </span>
        <span class="c1">#ensure connectivity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_repropose&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">PSEUDO</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
        
        <span class="c1"># Re-encrypt and add sk</span>
        <span class="n">cone</span> <span class="o">=</span> <span class="n">Reenc_one</span><span class="p">(</span><span class="n">Elgamal_key_mult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cone&#39;</span><span class="p">]))</span>
        <span class="n">cprop</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">Elgamal_key_mult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cprop&#39;</span><span class="p">]))</span>
        
        <span class="c1"># Update the information on the route </span>
        <span class="n">chopcount</span> <span class="o">=</span>  <span class="n">Elgamal_plain_mult</span><span class="p">(</span><span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;chopcount&#39;</span><span class="p">],</span> <span class="n">GROUP_G</span><span class="p">)</span>
        <span class="n">chopcount</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">Elgamal_key_mult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">chopcount</span><span class="p">))</span>
        
        <span class="n">cwhoisontheroute</span> <span class="o">=</span> <span class="n">Elgamal_accumulator_add</span><span class="p">(</span><span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;cwhoisontheroute&#39;</span><span class="p">],</span> <span class="s2">&quot; </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">))</span> 
        <span class="n">cwhoisontheroute</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">Elgamal_key_mult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">cwhoisontheroute</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_propose_route</span><span class="p">(</span><span class="n">rt_entry</span><span class="p">,</span> <span class="n">cprop</span><span class="p">,</span> <span class="n">cone</span><span class="p">,</span> <span class="n">chopcount</span><span class="p">,</span> <span class="n">cwhoisontheroute</span><span class="p">,</span> <span class="n">except_neighbor</span><span class="o">=</span><span class="n">pending_rt_prop</span><span class="p">[</span><span class="s1">&#39;proposer&#39;</span><span class="p">])</span>
            
    <span class="k">def</span> <span class="nf">_delayed_relay_rt_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rt_entry</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delays the relaying of a route proposal.</span>
<span class="sd">                </span>
<span class="sd">        Yields:</span>
<span class="sd">            :obj:`simpy.events.Timeout`: a simpy timeout event</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Wait for the delay to pass</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>

        <span class="c1"># Verify that the route still needs to be proposed. I.e. if by now, </span>
        <span class="c1"># at least one route was proposed for this pseudo, connectivity is ensured, </span>
        <span class="c1"># and there is no &quot;necessity&quot;</span>
        <span class="k">if</span> <span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">PSEUDO</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_rt_props</span><span class="p">[</span><span class="s1">&#39;to_repropose&#39;</span><span class="p">]:</span>
            <span class="k">return</span>
        
        <span class="c1"># Else, mark the entry as reproposed, and effectively relay the proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">update_entries</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="p">{</span><span class="n">RT</span><span class="o">.</span><span class="n">REPROPOSED</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="n">constraints</span><span class="o">=</span><span class="p">{</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">:</span> <span class="n">rt_entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_relay_rt_prop</span><span class="p">(</span><span class="n">rt_entry</span><span class="p">,</span> <span class="n">pending_rt_prop</span><span class="p">)</span>
        
          
            
            
                    
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Functions relating to the oriented communications, and commuinication</span>
    <span class="c1"># session initialisation</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ##########################################################################</span>
    <span class="c1"># ==========================================================================</span>
<div class="viewcode-block" id="Node.start_oriented_communications"><a class="viewcode-back" href="../../../apart.core.node.html#apart.core.node.Node.start_oriented_communications">[docs]</a>    <span class="k">def</span> <span class="nf">start_oriented_communications</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ocom_sessions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public function, called by the network manager, to ask the node to start the oriented communication phase</span>
<span class="sd">        </span>
<span class="sd">        Start an oriented communication is started with each receiver (and</span>
<span class="sd">        a different helper each) specified in `ocom_sessions`.</span>
<span class="sd">        </span>
<span class="sd">        If the `ocom_sessions` argument is not provided, a random one is</span>
<span class="sd">        generated.</span>
<span class="sd">        </span>
<span class="sd">        The `ocom_sessions` argument can be of the following form:</span>
<span class="sd">            * None: the node then chooses a random number of random communication partners</span>
<span class="sd">            * `dict[r] = list(data)` indicating thatthe node must send the list of data to each receiver r </span>
<span class="sd">            * `dict[r] = n` indicating that node must send n random pieces of data to each receiver r</span>
<span class="sd">            * `(n_r, n_data [, n_data2])` indicating that the node must choose n_r random receivers, and </span>
<span class="sd">              send them n_data random messages each. If n_data2 is provided, then the node </span>
<span class="sd">              chooses a random number of messages to send in [n_data, n_data2], different </span>
<span class="sd">              for each receiver  </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            ocom_sessions(None or dict or tuple): the sessions to initiate </span>
<span class="sd">               </span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="k">if</span> <span class="n">ocom_sessions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ocom_sessions</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ocom_sessions</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ocom_sessions</span><span class="p">:</span>
                <span class="n">nb_receivers</span> <span class="o">=</span> <span class="n">ocom_sessions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ocom_sessions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="n">ocom_sessions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">nb_data</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">aux</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aux1</span> <span class="o">=</span> <span class="n">ocom_sessions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">aux2</span> <span class="o">=</span> <span class="n">ocom_sessions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">nb_data</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">aux1</span><span class="p">,</span> <span class="n">aux2</span><span class="p">)</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nb_receivers</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
                <span class="n">nb_data</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            
            <span class="c1"># Ensure that the below &quot;while True&quot; does not loop forever</span>
            <span class="n">nb_receivers</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nb_receivers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">nb_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            

            <span class="n">ocom_sessions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_receivers</span><span class="p">):</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">receiver</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">nb_nodes</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">receiver</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">:</span><span class="c1">#and receiver not in ocom_sessions:</span>
                        <span class="k">break</span>
                <span class="n">ocom_sessions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">receiver</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;data </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_data</span><span class="p">())]))</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ocom_sessions</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> 
              <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> 
                  <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">nb_nodes</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
                  <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ocom_sessions</span><span class="p">)):</span>
            
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">ocom_sessions</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">ocom_sessions</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;data </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtocolError</span><span class="p">(</span><span class="s1">&#39;Node: oriented communication argument is not well formed (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ocom_sessions</span><span class="p">))</span>
    
            
        
<span class="c1">#         print(&quot;Node {}, sessions = {}&quot;.format(self.id, ocom_sessions))</span>
        <span class="k">for</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">ocom_sessions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start_ocom_session</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>
            
    <span class="k">def</span> <span class="nf">_start_ocom_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">data_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Starts an oriented communication to send the specified pieces of data to the specified receiver.</span>
<span class="sd">        </span>
<span class="sd">        This function begins by choosing a random helper, then obtains the</span>
<span class="sd">        shares of the receiver&#39;s dst value, sends the first set of messages part</span>
<span class="sd">        of the ocom initialisation to the helper. It also initiates the</span>
<span class="sd">        temporary storage for information on the communication session.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * receiver (int): identity of the receiver</span>
<span class="sd">            * data_list (object list): a list of heterogeneous object to send (usually, strings) </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">new_ocomid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">get_next_ocomid</span><span class="p">()</span>
        
        <span class="c1"># Choose a helper at random, by its pseudonym (generator used, avoiding</span>
        <span class="c1"># to fit all in memory)</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">],</span> 
                                            <span class="n">constraints</span><span class="o">=</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="o">+</span><span class="s2">&quot;!=? AND &quot;</span><span class="o">+</span><span class="n">RT</span><span class="o">.</span><span class="n">IN_USE</span><span class="o">+</span><span class="s2">&quot;=?&quot;</span><span class="p">,</span> 
                                            <span class="n">constraints_bindings</span><span class="o">=</span><span class="p">[</span><span class="n">F_NULL</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
        
        <span class="c1"># Choose an entry at random</span>
        <span class="n">entry_helper</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
        <span class="n">cone</span> <span class="o">=</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">]</span>
        <span class="n">next_node</span> <span class="o">=</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">]</span>
        <span class="n">next_cid</span> <span class="o">=</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">]</span>
                
        <span class="c1"># Now, contact the receiver &quot;offline&quot; to get the shares. To model that,</span>
        <span class="c1"># we directly invoke the receiver node&#39;s function</span>
        <span class="n">sh1</span><span class="p">,</span> <span class="n">csh2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">receiver</span><span class="p">]</span><span class="o">.</span><span class="n">_receiver_ocom_init_shares</span><span class="p">(</span><span class="n">new_ocomid</span><span class="p">,</span> <span class="n">Reenc_one</span><span class="p">(</span><span class="n">cone</span><span class="p">))</span>
        
        <span class="c1"># Generate the other necessary material</span>
        <span class="p">(</span><span class="n">pk_ocom</span><span class="p">,</span> <span class="n">sk_ocom</span><span class="p">)</span> <span class="o">=</span> <span class="n">Elgamal_keygen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">secparam</span><span class="p">)</span>
        <span class="p">(</span><span class="n">pk_tmp</span><span class="p">,</span> <span class="n">sk_tmp</span><span class="p">)</span> <span class="o">=</span> <span class="n">Elgamal_keygen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">secparam</span><span class="p">)</span>
        <span class="n">csh1</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="n">pk_ocom</span><span class="p">,</span> <span class="n">sh1</span><span class="p">)</span>
        <span class="n">msg_additional_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;is_ocom&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;end_sender&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;end_rcvr&#39;</span><span class="p">:</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">],</span> 
                               <span class="s1">&#39;ocom_helper&#39;</span><span class="p">:</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">],</span> 
                               <span class="s1">&#39;ocom_end_rcvr&#39;</span><span class="p">:</span> <span class="n">receiver</span><span class="p">,</span> <span class="s1">&#39;ocom_end_sender&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">}</span>
        
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> initiates an oriented communication ocomid(</span><span class="si">{}</span><span class="s2">) with helper </span><span class="si">{}</span><span class="s2">, end-sender </span><span class="si">{}</span><span class="s2">, and data = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">new_ocomid</span><span class="p">,</span> <span class="n">msg_additional_info</span><span class="p">[</span><span class="s1">&#39;ocom_helper&#39;</span><span class="p">],</span> <span class="n">msg_additional_info</span><span class="p">[</span><span class="s1">&#39;ocom_end_rcvr&#39;</span><span class="p">],</span> <span class="n">data_list</span><span class="p">))</span>
        
        <span class="c1"># Prepare the first set of  messages part of the oriented communication</span>
        <span class="c1"># initialisation: 4 payload messages, and 2 rt prop relay fwd ones      </span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">[</span><span class="n">pk_ocom</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">csh1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">csh1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">MsgInnerHeader</span><span class="p">(</span><span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_INIT</span><span class="p">,</span> <span class="n">ocomid</span><span class="o">=</span><span class="n">new_ocomid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">csh2</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">next_node</span><span class="p">,</span> 
                         <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                         <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">PAYLOAD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">next_cid</span><span class="p">,</span>
                         <span class="n">additional_info</span><span class="o">=</span><span class="n">msg_additional_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        
        <span class="c1"># For the helper to be able to answer, we send rtproprelay fwd messages.</span>
        <span class="c1"># This is done differently as described in the thesis, because here the</span>
        <span class="c1"># implementation of the route proposal policy directly gives us two</span>
        <span class="c1"># rtproprelay fwd msg (no need to send two with different rcid)</span>
        <span class="n">rcid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">get_next_rcid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">next_node</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">MsgInnerHeader</span><span class="p">(</span><span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_INIT</span><span class="p">,</span> <span class="n">ocomid</span><span class="o">=</span><span class="n">new_ocomid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">pk_tmp</span><span class="p">)</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">next_node</span><span class="p">,</span> 
                     <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                     <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_RELAY_FWD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">next_cid</span><span class="p">,</span> <span class="n">rcid</span><span class="o">=</span><span class="n">rcid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">additional_info</span><span class="o">=</span><span class="n">msg_additional_info</span><span class="p">)</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">next_node</span><span class="p">,</span> 
                     <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                     <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_RELAY_FWD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">next_cid</span><span class="p">,</span> <span class="n">rcid</span><span class="o">=</span><span class="n">rcid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                     <span class="n">additional_info</span><span class="o">=</span><span class="n">msg_additional_info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
        
        
        <span class="c1"># Store the info on the ocom init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">][</span><span class="n">new_ocomid</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;end_rcvr&#39;</span><span class="p">:</span> <span class="n">receiver</span><span class="p">,</span> <span class="s1">&#39;helper&#39;</span><span class="p">:</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">],</span>
                                                    <span class="s1">&#39;data_list&#39;</span><span class="p">:</span> <span class="n">data_list</span><span class="p">,</span>
                                                    <span class="s1">&#39;route_to_helper&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">],</span> 
                                                                        <span class="s1">&#39;cid&#39;</span><span class="p">:</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">],</span>
                                                                        <span class="s1">&#39;rcid&#39;</span><span class="p">:</span> <span class="n">rcid</span> <span class="p">,</span>
                                                                        <span class="s1">&#39;cone&#39;</span><span class="p">:</span> <span class="n">cone</span><span class="p">},</span>
                                                    <span class="s1">&#39;sk_ocom&#39;</span><span class="p">:</span> <span class="n">sk_ocom</span><span class="p">,</span>
                                                    <span class="s1">&#39;sk_tmp&#39;</span><span class="p">:</span> <span class="n">sk_tmp</span><span class="p">}</span>
        
        <span class="c1"># This second storage is for when the sender will receive back the rt</span>
        <span class="c1"># prop relay bwd msg, to easily recognise that it is part of an ocomm</span>
        <span class="c1"># init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">][(</span><span class="s1">&#39;rt_prop_relay_bwd_shortcut&#39;</span><span class="p">,</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">],</span> <span class="n">entry_helper</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">],</span> <span class="n">rcid</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_ocomid</span>
        
        <span class="c1"># For debugging purposes, also specify to the receiver what it is</span>
        <span class="c1"># supposed to receive. This is done directly, by access to the</span>
        <span class="c1"># :obj:`~apart.core.node.Node` object of the receiver.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">receiver</span><span class="p">]</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;to_receive&#39;</span><span class="p">][</span><span class="n">new_ocomid</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;data_list&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">data_list</span><span class="p">),</span>
                                                                             <span class="s1">&#39;started_at_round&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">}</span>
        
        <span class="c1"># Log the ocom route for statistics and measures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_ocom_route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_ocomid</span><span class="p">,</span> <span class="n">end_sender</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> 
                                                   <span class="n">helper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">][</span><span class="n">new_ocomid</span><span class="p">][</span><span class="s1">&#39;helper&#39;</span><span class="p">],</span>
                                                   <span class="n">end_rcvr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">][</span><span class="n">new_ocomid</span><span class="p">][</span><span class="s1">&#39;end_rcvr&#39;</span><span class="p">],</span>
                                                   <span class="n">first_hop_end_sender</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">][</span><span class="n">new_ocomid</span><span class="p">][</span><span class="s1">&#39;route_to_helper&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="s1">&#39;cid&#39;</span><span class="p">]))</span>

        
        
        
    <span class="k">def</span> <span class="nf">_receiver_ocom_init_shares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_ocomid</span><span class="p">,</span> <span class="n">helper_cone</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the share of the receivers&#39;s dst values</span>
<span class="sd">        </span>
<span class="sd">        This function basically models the *offline* exchange that an end-sender</span>
<span class="sd">        and end-receiver must perform prior to any oriented communication.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * new_ocomid (int): the oriented communication id chosen by the end-sender</span>
<span class="sd">            * helper_cone (:obj:`~apart.crypto.crypto.Ctxt`): the end-sender&#39;s encryption</span>
<span class="sd">                                            of one towards the helper she chose</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            * (int): the first share of the receiver&#39;s dst value</span>
<span class="sd">            * (:obj:`~apart.crypto.crypto.Ctxt`): the second share of the</span>
<span class="sd">                        receiver&#39;s dst value, encrypted using helper_cone</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sh1</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GROUP_P</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sh2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dst</span><span class="o">*</span><span class="n">group_inverse</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">%</span> <span class="n">GROUP_P</span>
        
        <span class="k">return</span> <span class="n">sh1</span><span class="p">,</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">helper_cone</span><span class="p">,</span> <span class="n">sh2</span><span class="p">)</span>
        
        
            
        
    <span class="k">def</span> <span class="nf">_handle_payload_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">payload_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler of :attr:`~apart.core.messages.MsgFlag.PAYLOAD` messages</span>
<span class="sd">        </span>
<span class="sd">        A node that receives a :attr:`~apart.core.messages.MsgFlag.PAYLOAD`</span>
<span class="sd">        message is either a relay, or its intended receiver. This is determined</span>
<span class="sd">        by a routing table lookup for the &quot;next hop&quot;. </span>
<span class="sd">        </span>
<span class="sd">        A relay node will simply send the message forward on the route. A</span>
<span class="sd">        receiver has several choices. The payload message can be of several</span>
<span class="sd">        type: an end-to-end dummy, an actual payload, or a routing message part</span>
<span class="sd">        of an oriented communication initialisation. This function then calls</span>
<span class="sd">        the appropriate *inner message handler*. </span>
<span class="sd">        </span>
<span class="sd">        Note: end-to-end dummies are detected early by the receiver,and do not</span>
<span class="sd">        have their own inner message handler</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            EndToEndDummyError: if the payload message is actually an end-to-end</span>
<span class="sd">                    dummy. This ugly fix is here to allow counting the number of</span>
<span class="sd">                    received e2e dummy in</span>
<span class="sd">                    :meth:`._round_process_received_messages`.</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="c1"># Fail early: instead of a rt lookup to see if we are the receiver,</span>
        <span class="c1"># first boldly try to decrypt the message and test the inner flag </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">payload_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">)</span><span class="o">.</span><span class="n">flag</span> <span class="ow">is</span> <span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">DUMMY</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">EndToEndDummyError</span><span class="p">(</span><span class="s2">&quot;Payload message is an end-to-end dummy&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">DecryptionError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">pass</span>
        
        <span class="n">entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">joint_lookup</span><span class="p">(</span><span class="n">PRT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">],</span> <span class="n">join_on</span><span class="o">=</span><span class="p">(</span><span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">,</span> <span class="n">PRT</span><span class="o">.</span><span class="n">RT_ROWID</span><span class="p">),</span> 
                             <span class="n">constraints</span><span class="o">=</span><span class="p">{</span><span class="n">PRT</span><span class="o">.</span><span class="n">PREV_NODE</span><span class="p">:</span> <span class="n">payload_msg</span><span class="o">.</span><span class="n">sent_by</span><span class="p">,</span> <span class="n">PRT</span><span class="o">.</span><span class="n">PREV_CID</span><span class="p">:</span> <span class="n">payload_msg</span><span class="o">.</span><span class="n">cid</span><span class="p">})</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Entry = </span><span class="si">{}</span><span class="s2">, Msg = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">([[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">],</span> <span class="n">payload_msg</span><span class="p">)</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">]</span> <span class="o">==</span> <span class="n">F_NULL</span><span class="p">:</span>
            <span class="c1"># The node is the receiver. Its action depends on the inner flag in</span>
            <span class="c1"># the first ciphertext of the message.</span>
            <span class="n">inner_header</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">payload_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">)</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inner_flag</span> <span class="o">=</span> <span class="n">inner_header</span><span class="o">.</span><span class="n">flag</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># This means it is a &quot;regular&quot; payload message, with plain data in it.</span>
                <span class="c1"># In a real implementation, we would send the data to the application layer</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Unknown inner message type. Message is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">payload_msg</span><span class="p">)</span>
                <span class="c1"># Because assertions are not run when python is invoked with</span>
                <span class="c1"># &quot;-O&quot;, we still make a failover</span>
                <span class="k">return</span>
            
            <span class="n">Node</span><span class="o">.</span><span class="n">__payload_msgs_handler</span><span class="p">[</span><span class="n">inner_flag</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">payload_msg</span><span class="p">,</span> <span class="n">inner_header</span><span class="p">)</span>  
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The node is a simple relay </span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">Reenc_one</span><span class="p">(</span><span class="n">Elgamal_key_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">payload_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">))</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">Reenc_nopk</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">Elgamal_key_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">payload_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">))</span>
            <span class="n">new_payload_msg</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">],</span> 
                                      <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                                      <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">PAYLOAD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">],</span> 
                                      <span class="n">additional_info</span><span class="o">=</span><span class="n">payload_msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">],</span> <span class="n">new_payload_msg</span><span class="p">)</span>
            
    <span class="k">def</span> <span class="nf">_helper_process_ocom_init_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">inner_header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Models the behavior of the helper in an oriented communication.</span>
<span class="sd">        </span>
<span class="sd">        In an oriented communication, the first seven messages are control ones,</span>
<span class="sd">        aimed at initializing the route (i.e. the send-senderand the helper</span>
<span class="sd">        computing the helper&#39;s pseudonym towards the end-receiver). Then, there</span>
<span class="sd">        are one more message per piece of data that the end-sender wishes to</span>
<span class="sd">        send.</span>
<span class="sd">        </span>
<span class="sd">        This funtion processes all these messages, managing a temporary storage</span>
<span class="sd">        to link them all together.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * msg (:obj:`~apart.core.messages.LinkMsg`): the received mesasge.</span>
<span class="sd">                        Can be a :attr:`~apart.core.messages.MsgFlag.PAYLOAD`</span>
<span class="sd">                        message, or a</span>
<span class="sd">                        :attr:`~apart.core.messages.MsgFlag.RTPROP_RELAY_FWD`</span>
<span class="sd">                        one.</span>
<span class="sd">            * inner_header (:obj:`~apart.core.message.MsgInnerHeader`): the</span>
<span class="sd">                        (decrypted) inner header,containing information on the</span>
<span class="sd">                        oriented communication session</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_to_sender</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">sent_by</span>
        <span class="n">cid_to_sender</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">cid</span>
        <span class="n">ocomid</span> <span class="o">=</span> <span class="n">inner_header</span><span class="o">.</span><span class="n">ocomid</span>
        <span class="n">seq_index</span> <span class="o">=</span> <span class="n">inner_header</span><span class="o">.</span><span class="n">seq_index</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">c2</span><span class="p">)</span>
        
         
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ongoing_ocom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;helper&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;helper&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nb_msgs_relayed&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  
                                                    <span class="s1">&#39;ocom_end_rcvr&#39;</span><span class="p">:</span> <span class="n">msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;ocom_end_rcvr&#39;</span><span class="p">],</span> 
                                                    <span class="s1">&#39;ocom_end_sender&#39;</span><span class="p">:</span> <span class="n">msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;ocom_end_sender&#39;</span><span class="p">]}</span>
            <span class="n">ongoing_ocom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;helper&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">seq_index</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># Wait to receive all the six first messages sent by the end-sender,</span>
            <span class="c1"># and when it is the case, send back two rt prop relay bwd msgs</span>
            <span class="k">if</span> <span class="n">seq_index</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;pk_tmp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;rcid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">rcid</span>
                    
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data_name</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pk_sender_ocom&#39;</span><span class="p">,</span> <span class="s1">&#39;sh2&#39;</span><span class="p">,</span> <span class="s1">&#39;csh1_0&#39;</span><span class="p">,</span> <span class="s1">&#39;csh1_1&#39;</span><span class="p">]</span>
                <span class="n">ongoing_ocom</span><span class="p">[</span><span class="n">data_name</span><span class="p">[</span><span class="n">seq_index</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span>
            
            <span class="c1"># When all six messages from the ocom have been received, the helper can</span>
            <span class="c1"># start answering</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">d</span> <span class="ow">in</span> <span class="n">ongoing_ocom</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pk_sender_ocom&#39;</span><span class="p">,</span> <span class="s1">&#39;sh2&#39;</span><span class="p">,</span> <span class="s1">&#39;csh1_0&#39;</span><span class="p">,</span> <span class="s1">&#39;csh1_1&#39;</span><span class="p">,</span> <span class="s1">&#39;rcid&#39;</span><span class="p">,</span> <span class="s1">&#39;pk_tmp&#39;</span><span class="p">]):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">ongoing_ocom</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;csh1_0&#39;</span><span class="p">),</span> <span class="n">ongoing_ocom</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;csh1_1&#39;</span><span class="p">))</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">Elgamal_scalar_exp</span><span class="p">(</span><span class="n">Elgamal_plain_mult</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ongoing_ocom</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sh2&#39;</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">Reenc_pk</span><span class="p">(</span><span class="n">ongoing_ocom</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pk_sender_ocom&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
                
                <span class="n">pk_tmp</span> <span class="o">=</span> <span class="n">ongoing_ocom</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pk_tmp&#39;</span><span class="p">)</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="n">pk_tmp</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="n">pk_tmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">c3</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="n">pk_tmp</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">c4</span> <span class="o">=</span> <span class="n">Elgamal_enc</span><span class="p">(</span><span class="n">pk_tmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                
                <span class="n">rcid</span> <span class="o">=</span> <span class="n">ongoing_ocom</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rcid&#39;</span><span class="p">)</span>
                <span class="n">additional_info</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">)</span>
                <span class="n">additional_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;end_sender&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;end_rcvr&#39;</span><span class="p">:</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;ocom_end_sender&#39;</span><span class="p">]})</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rt_prop_return_trip_relay_bwd</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_to_sender</span><span class="p">,</span> <span class="n">cid_to_sender</span><span class="p">,</span> <span class="n">rcid</span><span class="p">,</span> 
                                                    <span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rt_prop_return_trip_relay_bwd</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">node_to_sender</span><span class="p">,</span> <span class="n">cid_to_sender</span><span class="p">,</span> <span class="n">rcid</span><span class="p">,</span> 
                                                    <span class="n">c3</span><span class="p">,</span><span class="n">c4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>
                
        <span class="k">elif</span> <span class="n">seq_index</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="c1"># This is the payload message carrying the helper&#39;s pseudonym</span>
            <span class="c1"># towards the end-receiver</span>
            
            <span class="c1"># Choose a next hop for this pseudo. Note: the following code</span>
            <span class="c1"># handles well the special case when the slected helper is actually</span>
            <span class="c1"># the end-receiver.</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">],</span>
                                     <span class="n">constraints</span><span class="o">=</span><span class="p">{</span><span class="n">RT</span><span class="o">.</span><span class="n">PSEUDO</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">IN_USE</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;pseudo = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_node_table</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">))</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
            
            <span class="c1"># Store information on the route</span>
            <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;route_to_receiver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_NODE</span><span class="p">],</span>
                                                 <span class="s1">&#39;cid&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">NEXT_CID</span><span class="p">],</span>
                                                 <span class="s1">&#39;cone&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">CONE</span><span class="p">]}</span>
            
            <span class="c1"># Log the ocom route for statistics and measures</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_ocom_route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ocomid</span><span class="p">,</span> <span class="n">end_sender</span><span class="o">=</span><span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;ocom_end_sender&#39;</span><span class="p">],</span>
                                                   <span class="n">helper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                                   <span class="n">end_rcvr</span><span class="o">=</span><span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;ocom_end_rcvr&#39;</span><span class="p">],</span>
                                                   <span class="n">first_hop_helper</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;route_to_receiver&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="s1">&#39;cid&#39;</span><span class="p">]))</span>
            
            <span class="n">data_msg_buffer</span> <span class="o">=</span> <span class="n">ongoing_ocom</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data_msg_buffer&#39;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">waiting_seq_index</span><span class="p">,</span> <span class="n">waiting_data</span> <span class="ow">in</span> <span class="n">data_msg_buffer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_helper_relay_payload</span><span class="p">(</span><span class="n">ocomid</span><span class="p">,</span> <span class="n">ongoing_ocom</span><span class="p">,</span> <span class="n">waiting_seq_index</span><span class="p">,</span> <span class="n">waiting_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># An actual message carrying a payload, and with a seq_index &gt; 7.</span>
            <span class="c1"># Note that the helper may have received such a message BEFORE the</span>
            <span class="c1"># message with seq_index == 7, i.e. the one that contains the pseudo. </span>
            <span class="k">if</span> <span class="s1">&#39;route_to_receiver&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ongoing_ocom</span><span class="p">:</span>
                <span class="c1"># If the helper does not yet hnows the route towards the end-receiver,</span>
                <span class="c1"># insert the message in a waiting list</span>
                <span class="k">if</span> <span class="s1">&#39;data_msg_buffer&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ongoing_ocom</span><span class="p">:</span>
                    <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;data_msg_buffer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;data_msg_buffer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">seq_index</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Else, simply relay the message</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_helper_relay_payload</span><span class="p">(</span><span class="n">ocomid</span><span class="p">,</span> <span class="n">ongoing_ocom</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    
    
    <span class="k">def</span> <span class="nf">_helper_process_ocom_close_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">payload_msg</span><span class="p">,</span> <span class="n">inner_header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Processes the message received by the helper, that indicates the end of an oriented communication session.</span>
<span class="sd">        </span>
<span class="sd">        For the helper to know when it is ok to delete the temporary storage</span>
<span class="sd">        related to a communication session, the end-sender sends a</span>
<span class="sd">        :attr:`~apart.core.messages.MsgInnerFlag.OCOM_CLOSE` message</span>
<span class="sd">        (encapsulated in a :attr:`~apart.core.messages.MsgFlag.PAYLOAD`</span>
<span class="sd">        message). It tells how many messages the helper needs to forward in</span>
<span class="sd">        total.</span>
<span class="sd">        </span>
<span class="sd">        Note that, by the way forwarding works, this &quot;close&quot; message may arrive</span>
<span class="sd">        before the helper even gets all the messages containing the data to</span>
<span class="sd">        relay. Thus, this function does not automatically deletes the temporary</span>
<span class="sd">        storage. In some cases, it only raises a flag, saying *when* it should</span>
<span class="sd">        be deleted.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * payload_msg (:obj:`~apart.core.messages.LinkMsg`): the received </span>
<span class="sd">                        :attr:`~apart.core.messages.MsgFlag.PAYLOAD` message.</span>
<span class="sd">            * inner_header (:obj:`~apart.core.message.MsgInnerHeader`): the</span>
<span class="sd">                        (decrypted) inner header,containing information on the</span>
<span class="sd">                        oriented communication session</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">ocomid</span> <span class="o">=</span> <span class="n">inner_header</span><span class="o">.</span><span class="n">ocomid</span>
        <span class="n">ongoing_ocom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;helper&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span>
        <span class="n">nb_msgs_total</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">payload_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">)</span>
        
        <span class="c1"># Delete the temporary storage only if all messages have </span>
        <span class="c1"># been forwarded to the receiver. Not always the case, since </span>
        <span class="c1"># messages arrive in unpredictable order  </span>
        <span class="k">if</span> <span class="s1">&#39;nb_msgs_relayed&#39;</span> <span class="ow">in</span> <span class="n">ongoing_ocom</span> <span class="ow">and</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;nb_msgs_relayed&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">nb_msgs_total</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;helper&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;nb_msgs_total&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_msgs_total</span>
            
    <span class="k">def</span> <span class="nf">_helper_relay_payload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ocomid</span><span class="p">,</span> <span class="n">ongoing_ocom</span><span class="p">,</span> <span class="n">seq_index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The relaying by the helper of a payload message in an oriented communication</span>
<span class="sd">        </span>
<span class="sd">        This function simply crafts a payload message, and sends it on the pre-</span>
<span class="sd">        selectionned route to the receiver (the description of the route is in</span>
<span class="sd">        the ``ongoing_ocom`` argument).</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * ocomid (int): the id of the communication session</span>
<span class="sd">            * ongoing_ocom (:obj:dict`): temporary stored info on the </span>
<span class="sd">                            communication session</span>
<span class="sd">            * seq_index(int): the sequence number of the payload </span>
<span class="sd">            * data (object): the data to send</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">next_node</span> <span class="o">=</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;route_to_receiver&#39;</span><span class="p">][</span><span class="s1">&#39;node&#39;</span><span class="p">]</span>
        <span class="n">next_cid</span> <span class="o">=</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;route_to_receiver&#39;</span><span class="p">][</span><span class="s1">&#39;cid&#39;</span><span class="p">]</span>
        <span class="n">cone</span> <span class="o">=</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;route_to_receiver&#39;</span><span class="p">][</span><span class="s1">&#39;cone&#39;</span><span class="p">]</span>
        <span class="n">additional_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;is_ocom&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;is_ocom_payload&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> 
                           <span class="s1">&#39;end_sender&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;end_rcvr&#39;</span><span class="p">:</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;ocom_end_rcvr&#39;</span><span class="p">],</span> 
                           <span class="s1">&#39;ocom_helper&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;ocom_end_sender&#39;</span><span class="p">:</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;ocom_end_sender&#39;</span><span class="p">],</span> <span class="s1">&#39;ocom_end_rcvr&#39;</span><span class="p">:</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;ocom_end_rcvr&#39;</span><span class="p">]}</span>
        
        <span class="k">if</span> <span class="n">next_node</span> <span class="o">==</span> <span class="n">F_NULL</span><span class="p">:</span>
            <span class="c1"># Special case: the helper is actually the end-receiver !</span>
            <span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;end_sender&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;ocom_end_sender&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_receiver_process_ocom_rcv_msg</span><span class="p">(</span><span class="n">ocomid</span><span class="p">,</span> <span class="n">seq_index</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># General case</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">MsgInnerHeader</span><span class="p">(</span><span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_RCV</span><span class="p">,</span> <span class="n">ocomid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="n">seq_index</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">next_node</span><span class="p">,</span> 
                        <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                        <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">PAYLOAD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">next_cid</span><span class="p">,</span> 
                        <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>           
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>      
        
        <span class="c1"># Update the number of messages sent towards te receiver</span>
        <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;nb_msgs_relayed&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> 
        
        <span class="c1"># Verify if this was the last message to relay. If so, </span>
        <span class="c1"># delete the temporary storage</span>
        <span class="k">if</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;nb_msgs_relayed&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ongoing_ocom</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nb_msgs_total&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;helper&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">_sender_ocom_init_finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ocomid</span><span class="p">,</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Second step for the sender in an oriented communication.</span>
<span class="sd">        </span>
<span class="sd">        After starting the ocom init (by sending the first 4</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.PAYLOAD` messages and 2</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RT_PROP_RELAY_FWD` ones to the</span>
<span class="sd">        helper), the sender expects to receive two</span>
<span class="sd">        :attr:`~apart.core.messages.MsgFlag.RT_PROP_RELAY_BWD` messages, each</span>
<span class="sd">        containing a piece of the ciphertext encrypting dstR**srcI.</span>
<span class="sd">        </span>
<span class="sd">        This allows the end-sender to compute the helper&#39;s pseudonym towards the</span>
<span class="sd">        end-receiver, to send it back, and to start sending the pieces of data.</span>
<span class="sd">        </span>
<span class="sd">        At the end of this function, the temporary storage of the end-sender</span>
<span class="sd">        concerning the ocom session is deleted.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * ocomid (int): the id of the communication session</span>
<span class="sd">            * rt_prop_relay_bwd_msg (:obj:dict`): the received </span>
<span class="sd">                        :attr:`~apart.core.messages.MsgFlag.RT_PROP_RELAY_BWD`</span>
<span class="sd">                        message</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="n">ongoing_ocom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span>
        
        
        <span class="n">cpseudo_part</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sk_tmp&#39;</span><span class="p">],</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">c1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">seq_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;cpseudo_0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpseudo_part</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;cpseudo_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpseudo_part</span>
        
        <span class="c1"># When both rt prop relay bwd messages have been receiver,</span>
        <span class="c1"># process them, and get back to the helper</span>
        <span class="k">if</span> <span class="s1">&#39;cpseudo_0&#39;</span> <span class="ow">in</span> <span class="n">ongoing_ocom</span> <span class="ow">and</span> <span class="s1">&#39;cpseudo_1&#39;</span> <span class="ow">in</span> <span class="n">ongoing_ocom</span><span class="p">:</span>
            <span class="n">cpseudo</span> <span class="o">=</span> <span class="p">(</span><span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;cpseudo_0&#39;</span><span class="p">],</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;cpseudo_1&#39;</span><span class="p">])</span>
            <span class="n">pseudo</span> <span class="o">=</span> <span class="n">SHA3_hash</span><span class="p">(</span><span class="n">Elgamal_dec</span><span class="p">(</span><span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sk_ocom&#39;</span><span class="p">],</span> <span class="n">cpseudo</span><span class="p">))</span>
            <span class="n">cone</span> <span class="o">=</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;route_to_helper&#39;</span><span class="p">][</span><span class="s1">&#39;cone&#39;</span><span class="p">]</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;route_to_helper&#39;</span><span class="p">][</span><span class="s1">&#39;node&#39;</span><span class="p">]</span>
            <span class="n">next_cid</span> <span class="o">=</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;route_to_helper&#39;</span><span class="p">][</span><span class="s1">&#39;cid&#39;</span><span class="p">]</span>            
            <span class="n">additional_info</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">)</span>
            <span class="n">additional_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;end_sender&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;end_rcvr&#39;</span><span class="p">:</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;helper&#39;</span><span class="p">]})</span> 
            
            <span class="c1"># Prepare the message containing the helper&#39;s pseudonym towards the receiver</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">MsgInnerHeader</span><span class="p">(</span><span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_INIT</span><span class="p">,</span> <span class="n">ocomid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="mi">7</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">pseudo</span><span class="p">)</span>
            <span class="n">m_pseudo</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">next_node</span><span class="p">,</span> 
                               <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                               <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">PAYLOAD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">next_cid</span><span class="p">,</span>
                               <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">m_pseudo</span><span class="p">)</span>
            
            <span class="c1"># Prepare one payload message for each piece of data to send</span>
            <span class="c1"># to the end receiver</span>
            <span class="n">additional_info</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">additional_info</span><span class="p">)</span>
            <span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;is_ocom_payload&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> 
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;data_list&#39;</span><span class="p">]):</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">MsgInnerHeader</span><span class="p">(</span><span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_INIT</span><span class="p">,</span> <span class="n">ocomid</span><span class="p">,</span> <span class="n">seq_index</span><span class="o">=</span><span class="mi">8</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c1"># If AES encryption is implemented, &quot;data&quot; should be encrypted here</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">next_node</span><span class="p">,</span> 
                            <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                            <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">PAYLOAD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">next_cid</span><span class="p">,</span>
                            <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                
            <span class="c1"># Send the special message that closes the session (i.e. </span>
            <span class="c1"># that lets the helper know the session is over)</span>
            <span class="n">additional_info</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">additional_info</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;is_ocom_payload&#39;</span><span class="p">]</span>  
            <span class="n">c1</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="n">MsgInnerHeader</span><span class="p">(</span><span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_CLOSE</span><span class="p">,</span> <span class="n">ocomid</span><span class="p">))</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">Elgamal_enc_nopk</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;data_list&#39;</span><span class="p">]))</span> 
            <span class="n">m</span> <span class="o">=</span> <span class="n">LinkMsg</span><span class="p">(</span><span class="n">sent_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sent_to</span><span class="o">=</span><span class="n">next_node</span><span class="p">,</span> 
                        <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> 
                        <span class="n">flag</span><span class="o">=</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">PAYLOAD</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">next_cid</span><span class="p">,</span>
                        <span class="n">additional_info</span><span class="o">=</span><span class="n">additional_info</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_place_msg_in_pool</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>     
            
            <span class="c1"># For debug purposes, inform the receiver of when the actual ocom starts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;end_rcvr&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;to_receive&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;first_payload_sent_at_round&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">})</span>
        
            <span class="c1"># Delete all temporary stored information</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">][(</span><span class="s1">&#39;rt_prop_relay_bwd_shortcut&#39;</span><span class="p">,</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">sent_by</span><span class="p">,</span> <span class="n">rt_prop_relay_bwd_msg</span><span class="o">.</span><span class="n">cid</span><span class="p">,</span> <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;route_to_helper&#39;</span><span class="p">][</span><span class="s1">&#39;rcid&#39;</span><span class="p">])]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;sender&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span>
            
    
             
    
    <span class="k">def</span> <span class="nf">_handle_payload_ocom_rcv_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">payload_msg</span><span class="p">,</span> <span class="n">inner_header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler of :attr:`~apart.core.messages.MsgInnerFlag.OCOM_RCV` message, for the end-receiver of oriented communications</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * payload_msg (:obj:`~apart.core.messages.LinkMsg`): the received </span>
<span class="sd">                        :attr:`~apart.core.messages.MsgFlag.PAYLOAD` message.</span>
<span class="sd">            * inner_header (:obj:`~apart.core.message.MsgInnerHeader`): the</span>
<span class="sd">                        (decrypted) inner header,containing information on the</span>
<span class="sd">                        oriented communication session</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ocomid</span> <span class="o">=</span> <span class="n">inner_header</span><span class="o">.</span><span class="n">ocomid</span>
        <span class="n">seq_index</span> <span class="o">=</span> <span class="n">inner_header</span><span class="p">;</span><span class="n">seq_index</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">Elgamal_dec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sk</span><span class="p">,</span> <span class="n">payload_msg</span><span class="o">.</span><span class="n">c2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_receiver_process_ocom_rcv_msg</span><span class="p">(</span><span class="n">ocomid</span><span class="p">,</span> <span class="n">seq_index</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">payload_msg</span><span class="o">.</span><span class="n">additional_info</span><span class="p">)</span>
        

    <span class="k">def</span> <span class="nf">_receiver_process_ocom_rcv_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ocomid</span><span class="p">,</span> <span class="n">seq_index</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">additional_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Receiving of actual data from an oriented communication.</span>
<span class="sd">        </span>
<span class="sd">        This is the function where an end-receiver of an oriented communication</span>
<span class="sd">        processes the data it receives. Recall that data is contained (only) in</span>
<span class="sd">        the second ciphertext of :attr:`~apart.core.messages.MsgFlag.PAYLOAD`,</span>
<span class="sd">        the first one containing an inner header allowing to re-order messages.</span>
<span class="sd">        </span>
<span class="sd">        In an acutal implementation, the data received should be passed on to</span>
<span class="sd">        the *application layer*. Here, all this function does is logging the</span>
<span class="sd">        received message.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            * ocomid (int): the identifier of the communication session</span>
<span class="sd">            * seq_index (int): sequence number of the piece of data </span>
<span class="sd">            * data (object): the piece of data to receive</span>
<span class="sd">            * additional_info (:obj:`dict` or None): optional additional </span>
<span class="sd">                        information on the communication session </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> end-received &#39;</span><span class="si">{}</span><span class="s2">&#39; as part of an oriented communication ocomid(</span><span class="si">{}</span><span class="s2">) with end-sender </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ocomid</span><span class="p">,</span> <span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;end_sender&#39;</span><span class="p">]))</span>
        
<span class="c1">#         self._net_manager.net_stats.log_rcvd_ocom_msg(self, data)</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;ocom_end_rcvr&#39;</span><span class="p">]</span>
        <span class="n">ongoing_ocom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;to_receive&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span>
        <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;data_list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;data_list&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_net_manager</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">log_ocom_latency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">additional_info</span><span class="p">[</span><span class="s1">&#39;end_sender&#39;</span><span class="p">],</span> 
                                                         <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;started_at_round&#39;</span><span class="p">],</span>
                                                         <span class="n">ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;first_payload_sent_at_round&#39;</span><span class="p">])</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ongoing_ocom</span><span class="p">[</span><span class="s1">&#39;to_receive&#39;</span><span class="p">][</span><span class="n">ocomid</span><span class="p">]</span>
        
        




    <span class="c1">#===========================================================================</span>
    <span class="c1"># Misc. functions</span>
    <span class="c1">#===========================================================================</span>
<div class="viewcode-block" id="Node.display_node_table"><a class="viewcode-back" href="../../../apart.core.node.html#apart.core.node.Node.display_node_table">[docs]</a>    <span class="k">def</span> <span class="nf">display_node_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s2">&quot;rt+prt&quot;</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Print one or sevral of the node&#39;s routing tables. Used for debug purposes&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I am node </span><span class="si">{}</span><span class="s2">, at round </span><span class="si">{}</span><span class="s2"> (ime is </span><span class="si">{}</span><span class="s2">), and here is my routing table (</span><span class="si">{}</span><span class="s2">):&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batching_round</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">table</span><span class="p">))</span>
        

        <span class="k">if</span> <span class="n">table</span> <span class="o">==</span> <span class="s2">&quot;rt+prt&quot;</span><span class="p">:</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">PRT</span><span class="o">.</span><span class="n">PREV_NODE</span><span class="p">,</span> <span class="n">PRT</span><span class="o">.</span><span class="n">PREV_CID</span><span class="p">]</span> <span class="o">+</span> \
                      <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">RT</span><span class="o">.</span><span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">RT</span><span class="o">.</span><span class="n">NODE</span><span class="p">]</span>
            <span class="n">join_on</span> <span class="o">=</span> <span class="p">(</span><span class="n">PRT</span><span class="o">.</span><span class="n">RT_ROWID</span><span class="p">,</span> <span class="n">RT</span><span class="o">.</span><span class="n">ROWID</span><span class="p">)</span>
            <span class="n">contents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">joint_lookup</span><span class="p">(</span><span class="n">PRT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">fields</span><span class="p">,</span> <span class="n">join_on</span><span class="o">=</span><span class="n">join_on</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">,</span> <span class="n">PRT</span><span class="o">.</span><span class="n">PREV_NODE</span><span class="p">])</span>
            <span class="n">pprinttable</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">contents</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">table</span> <span class="o">==</span> <span class="s2">&quot;rt&quot;</span><span class="p">:</span>
            <span class="n">pprinttable</span><span class="p">(</span><span class="n">RT</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">rt</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="p">[</span><span class="n">RT</span><span class="o">.</span><span class="n">ACTUAL_RCVR</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">table</span> <span class="o">==</span> <span class="s2">&quot;prt&quot;</span><span class="p">:</span>
            <span class="n">pprinttable</span><span class="p">(</span><span class="n">PRT</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prt</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="p">[</span><span class="n">PRT</span><span class="o">.</span><span class="n">RT_ROWID</span><span class="p">]))</span>

        <span class="nb">print</span><span class="p">()</span></div>
    
    
    <span class="c1"># Dict mapping message type to node function to process them. Put as static</span>
    <span class="c1"># member to avoid re-constructing it at each Node instance (or even each</span>
    <span class="c1"># call of function)</span>
    <span class="n">__msg_handlers</span> <span class="o">=</span> <span class="p">{</span><span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP</span><span class="p">:</span> <span class="n">_handle_rt_prop_msg</span><span class="p">,</span>
                      <span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_ANSWER</span><span class="p">:</span> <span class="n">_handle_rt_prop_answer_msg</span><span class="p">,</span>
                      <span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_FINAL</span><span class="p">:</span> <span class="n">_handle_rt_prop_final_msg</span><span class="p">,</span>
                      <span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_RELAY_FWD</span><span class="p">:</span> <span class="n">_handle_rt_prop_relay_fwd_msg</span><span class="p">,</span>
                      <span class="n">MsgFlag</span><span class="o">.</span><span class="n">RTPROP_RELAY_BWD</span><span class="p">:</span> <span class="n">_handle_rt_prop_relay_bwd_msg</span><span class="p">,</span>
                      <span class="n">MsgFlag</span><span class="o">.</span><span class="n">PAYLOAD</span><span class="p">:</span> <span class="n">_handle_payload_msg</span><span class="p">}</span>

    <span class="n">__payload_msgs_handler</span> <span class="o">=</span> <span class="p">{</span><span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_INIT</span><span class="p">:</span> <span class="n">_helper_process_ocom_init_msg</span><span class="p">,</span>
                              <span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_CLOSE</span><span class="p">:</span> <span class="n">_helper_process_ocom_close_msg</span><span class="p">,</span>
                              <span class="n">MsgInnerFlag</span><span class="o">.</span><span class="n">OCOM_RCV</span><span class="p">:</span> <span class="n">_handle_payload_ocom_rcv_msg</span><span class="p">}</span></div>



<div class="viewcode-block" id="ProtocolError"><a class="viewcode-back" href="../../../apart.core.node.html#apart.core.node.ProtocolError">[docs]</a><span class="k">class</span> <span class="nc">ProtocolError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception raised when an error occurs in the protocol&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, University of Rennes 1 (author: Antoine Guellier).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>