

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>measure_privacy — Measure Privacy &mdash; APART  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="APART  documentation" href="index.html"/>
        <link rel="up" title="Examples" href="examples.html"/>
        <link rel="next" title="measure_all — Perform all three measures at once" href="examples.measure_all.html"/>
        <link rel="prev" title="measure_route_prop — Study the route proposal mechanism" href="examples.measure_route_prop.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="contents.html" class="icon icon-home"> APART
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">APART</a></li>
<li class="toctree-l1"><a class="reference internal" href="packages.html">Packages</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="examples.html">Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="examples.measure_general_efficiency.html"><code class="docutils literal"><span class="pre">measure_general_efficiency</span></code> &#8212; Measure Performances</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.measure_route_prop.html"><code class="docutils literal"><span class="pre">measure_route_prop</span></code> &#8212; Study the route proposal mechanism</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><code class="docutils literal"><span class="pre">measure_privacy</span></code> &#8212; Measure Privacy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#source-code">Source Code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="examples.measure_all.html"><code class="docutils literal"><span class="pre">measure_all</span></code> &#8212; Perform all three measures at once</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="contents.html">APART</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="contents.html">Docs</a> &raquo;</li>
        
          <li><a href="examples.html">Examples</a> &raquo;</li>
        
      <li><code class="docutils literal"><span class="pre">measure_privacy</span></code> &#8212; Measure Privacy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/examples.measure_privacy.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-measure_privacy">
<span id="measure-privacy-measure-privacy"></span><h1><code class="docutils literal"><span class="pre">measure_privacy</span></code> &#8212; Measure Privacy<a class="headerlink" href="#module-measure_privacy" title="Permalink to this headline">¶</a></h1>
<p>Example module to makes simulations and measures on the APART protocol. This
module runs network simulation and makes measures on the privacy provided by the
protocol.</p>
<p>More specifically, this module measures the receiver anonymity. This metric is
computed in function of the number of nodes in the network, and of the
corruption ratio.</p>
<div class="section" id="source-code">
<h2>Source Code<a class="headerlink" href="#source-code" title="Permalink to this headline">¶</a></h2>
<p>Refer to the source code for more detail. It is depicted below, and can be
downloaded <a class="reference download internal" href="_downloads/measure_privacy.py" download=""><code class="xref download docutils literal"><span class="pre">here</span></code></a>.</p>
<p>The code is outlined as follows:</p>
<ul>
<li><p class="first">Definitions of constants:</p>
<blockquote>
<div><ul>
<li><p class="first">The metrics (statistics names) that the module computes
(<code class="xref py py-attr docutils literal"><span class="pre">MEASURE_STATS</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The value for each constant listed in <code class="xref py py-attr docutils literal"><span class="pre">MEASURE_STATS</span></code> is a
string (with spelling mistakes, I know). However, it can be
anything as long as it is serialisable data, and ensures
uniqueness of values. We chose strings for it makes its easy to
identify metrics during debug, or when printing results out on
stdout.</p>
</div>
</li>
<li><p class="first">The name of the measure defined in this module
(<code class="xref py py-attr docutils literal"><span class="pre">MEASURE_TITLE</span></code>).</p>
</li>
<li><p class="first">The parameters relevant for this measure module
(<code class="xref py py-attr docutils literal"><span class="pre">MEASURE_PARAMS</span></code>), <em>i.e.</em> network and  simulation
parameters (see <a class="reference internal" href="apart.simulation.html#apart.simulation.SimulationParams" title="apart.simulation.SimulationParams"><code class="xref py py-class docutils literal"><span class="pre">SimulationParams</span></code></a> and
<a class="reference internal" href="apart.core.network.html#apart.core.network.NetworkParams" title="apart.core.network.NetworkParams"><code class="xref py py-class docutils literal"><span class="pre">NetworkParams</span></code></a>).</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The function <a class="reference internal" href="examples.measure_general_efficiency.html#module-measure_general_efficiency" title="measure_general_efficiency"><code class="xref py py-func docutils literal"><span class="pre">measure_general_efficiency()</span></code></a>), which basically calls
<a class="reference internal" href="measures.common_measures.html#measures.common_measures.generic_measure" title="measures.common_measures.generic_measure"><code class="xref py py-func docutils literal"><span class="pre">measures.common_measures.generic_measure()</span></code></a>. Prior to this calls, it
performs checks on the simulation and network parameters.</p>
</li>
<li><p class="first">The <code class="xref py py-func docutils literal"><span class="pre">get_sim_params()</span></code> function, returning an instance of
<a class="reference internal" href="apart.simulation.html#apart.simulation.SimulationParams" title="apart.simulation.SimulationParams"><code class="xref py py-obj docutils literal"><span class="pre">SimulationParams</span></code></a> with custom parameter values.</p>
</li>
<li><p class="first">The <code class="xref py py-func docutils literal"><span class="pre">compute_metrics_one_network_run()</span></code> function, which is the callback
function to provide as <code class="docutils literal"><span class="pre">metric_computer_callback</span></code> to
<a class="reference internal" href="measures.common_measures.html#measures.common_measures.generic_measure" title="measures.common_measures.generic_measure"><code class="xref py py-func docutils literal"><span class="pre">measures.common_measures.generic_measure()</span></code></a>.</p>
</li>
<li><p class="first">Then, this module defines only <em>one</em> plotting function:
<code class="xref py py-func docutils literal"><span class="pre">plot_RECEIVER_ANONYMITY_vs_theoretical()</span></code>. Contrarily to plotting
functions in the other example measure modules, the latter function is however
very complex, and broken down over several module-private functions. Indeed,
in this module, the only information gathered during the network simulations,
as per the definition of <code class="xref py py-func docutils literal"><span class="pre">compute_metrics_one_network_run()</span></code>, are the
description of routes (<em>i.e.</em> a list of routes, as given by
<a class="reference internal" href="measures.advanced_stats_helper.html#measures.advanced_stats_helper.AdvancedNetworkStatsHelper.AdvancedNetworkStatsHelperSingleton.complete_routes_descriptions" title="measures.advanced_stats_helper.AdvancedNetworkStatsHelper.AdvancedNetworkStatsHelperSingleton.complete_routes_descriptions"><code class="xref py py-attr docutils literal"><span class="pre">complete_routes_descriptions</span></code></a>
from the <a class="reference internal" href="measures.advanced_stats_helper.html#module-measures.advanced_stats_helper" title="measures.advanced_stats_helper"><code class="xref py py-mod docutils literal"><span class="pre">measures.advanced_stats_helper</span></code></a> module. It is then the role of
function <code class="xref py py-func docutils literal"><span class="pre">plot_RECEIVER_ANONYMITY_vs_theoretical()</span></code> to process these
routes descriptions in order to deduce the receiver anonymity. Note that the
function accepts corruptions ratios as argument (with the
<code class="docutils literal"><span class="pre">results_augmentation</span></code> a parameter).</p>
</li>
<li><p class="first">A <em>main</em> part, allowing to perform measures and/or plot previously acquired
measure results.</p>
</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Author: Antoine Guellier</span>
<span class="c1"># Copyright (c) 2017 Université de Rennes 1</span>
<span class="c1"># License: CeCILL. The full license text is available at:</span>
<span class="c1">#  - http://www.cecill.info/licences/Licence_CeCILL_V2.1-fr.html</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Example module to makes simulations and measures on the APART protocol. This</span>
<span class="sd">module runs network simulation and makes measures on the privacy provided by the</span>
<span class="sd">protocol.</span>

<span class="sd">More specifically, this module measures the receiver anonymity. This metric is</span>
<span class="sd">computed in function of the number of nodes in the network, and of the</span>
<span class="sd">corruption ratio.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">curve_fit</span>
<span class="kn">import</span> <span class="nn">statistics</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;..&#39;</span><span class="p">,</span> <span class="s1">&#39;src&#39;</span><span class="p">)))</span>


<span class="kn">from</span> <span class="nn">apart.core.network</span> <span class="k">import</span> <span class="n">NetworkParams</span><span class="p">,</span> <span class="n">NetworkManager</span><span class="p">,</span> <span class="n">Network</span><span class="p">,</span> \
    <span class="n">SimulationException</span>
<span class="kn">from</span> <span class="nn">apart.core.protocol_constants</span> <span class="k">import</span> <span class="n">RtPolicyReason</span>
<span class="kn">from</span> <span class="nn">apart.core.tables</span> <span class="k">import</span> <span class="n">RoutingTable</span>
<span class="kn">from</span> <span class="nn">apart.simulation</span> <span class="k">import</span> <span class="n">SimulationParams</span>
<span class="kn">from</span> <span class="nn">common.custom_logging</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">common.utilities</span> <span class="k">import</span> <span class="n">print_recursive_structure</span><span class="p">,</span> <span class="n">range1</span><span class="p">,</span> \
    <span class="n">make_hashable</span><span class="p">,</span> <span class="n">comb</span>
<span class="kn">import</span> <span class="nn">dill</span> <span class="k">as</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">measures.advanced_stats_helper</span> <span class="k">import</span> <span class="n">AdvancedNetworkStatsHelper</span>
<span class="kn">from</span> <span class="nn">measures.common_measures</span> <span class="k">import</span> <span class="n">MeasureException</span><span class="p">,</span> <span class="n">generic_measure</span><span class="p">,</span> \
    <span class="n">save_measures_results</span><span class="p">,</span> <span class="n">load_measures_results</span><span class="p">,</span> \
    <span class="n">preprocess_measure_input_params</span><span class="p">,</span> <span class="n">make_params_combinations</span><span class="p">,</span> \
    <span class="n">merge_measures_outputs_with_prefix</span><span class="p">,</span> <span class="n">merge_measures_outputs</span>
<span class="kn">from</span> <span class="nn">measures.file_handling</span> <span class="k">import</span> <span class="n">save_graphs_simulation_results</span>
<span class="kn">from</span> <span class="nn">measures.network_statistics</span> <span class="k">import</span> <span class="n">RegularStat</span><span class="p">,</span> <span class="n">RunningStat</span>
<span class="kn">from</span> <span class="nn">measures.plotting</span> <span class="k">import</span> <span class="n">do_plot_simple_metric</span><span class="p">,</span><span class="n">process_plot_function_inputs</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>




<span class="n">_RECEIVER_ANONYMITY</span> <span class="o">=</span> <span class="s2">&quot;Overall receiver anonymity&quot;</span>
<span class="n">_RECEIVER_ANONYMITY_HIST_NORMALISED_ENTROPY</span> <span class="o">=</span> <span class="s2">&quot;receiver anonymity: normalised entropy&quot;</span>
<span class="n">_RECEIVER_ANONYMITY_HIST_PROB_MOST_LIKELY</span> <span class="o">=</span> <span class="s2">&quot;receiver anonymity: probability of most likely receiver in the prob distrib&quot;</span>
<span class="n">_RECEIVER_ANONYMITY_FREQ_GOOD_GUESS</span> <span class="o">=</span> <span class="s2">&quot;receiver anonymity: number of times or frequency at which the adversary would guess right&quot;</span>

<span class="n">_HIST_SIMPLE_ROUTE_LENGTH</span> <span class="o">=</span> <span class="s2">&quot;Dict[k] = v, for k = route length,v = nb routes with this length&quot;</span>
<span class="n">_CORRUPTION_STATES</span> <span class="o">=</span> <span class="s2">&quot;Corrupted and honest nodes in the network&quot;</span>
<span class="n">_TOPOLOGY_GRAPH</span> <span class="o">=</span> <span class="s2">&quot;Topology graph of the network&quot;</span>
<span class="n">_FULL_OCOM_ROUTES</span> <span class="o">=</span> <span class="s2">&quot;All ocom routes in a network run&quot;</span>


<span class="n">MEASURE_STATS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_RECEIVER_ANONYMITY&#39;</span><span class="p">]</span>

<span class="c1"># Title of the measures performed in this module</span>
<span class="n">MEASURE_TITLE</span> <span class="o">=</span> <span class="s1">&#39;Privacy&#39;</span>

<span class="c1"># Network parameters that vary for the measures uin this module</span>
<span class="n">_MEASURE_PARAMS_DEFAULT</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;nb_nodes&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="mi">30</span><span class="p">)),</span> 
                                       <span class="p">(</span><span class="s1">&#39;corruption_ratio&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">))</span>
                                       <span class="p">])</span>
<span class="n">MEASURE_PARAMS</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_MEASURE_PARAMS_DEFAULT</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<span class="c1"># Default folder where to save the </span>
<span class="n">_DEFAULT_SAVING_FOLDER</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;Measures/&#39;</span><span class="p">))</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">_DEFAULT_SAVING_FOLDER</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">_DEFAULT_SAVING_FOLDER</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mo">0o775</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">measure_privacy</span><span class="p">(</span><span class="n">save_results_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_network_states</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">restrict_to_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force_recomputation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">measure_params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calls :func:`measures.common_measures.generic_measure` after some pre-processing.&quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">save_results_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">save_results_to</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_DEFAULT_SAVING_FOLDER</span><span class="p">,</span> <span class="n">MEASURE_TITLE</span><span class="p">)</span>
    
    <span class="n">preprocess_measure_input_params</span><span class="p">(</span><span class="n">_MEASURE_PARAMS_DEFAULT</span><span class="p">,</span> <span class="n">measure_params</span><span class="p">)</span>
    
    <span class="n">nb_iters</span><span class="o">=</span> <span class="n">measure_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nb_iters&#39;</span><span class="p">)</span>
    <span class="n">nb_iters_same_topo_graph</span><span class="o">=</span> <span class="n">measure_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nb_iters_same_topo_graph&#39;</span><span class="p">)</span>
    <span class="n">net_params_combinations</span> <span class="o">=</span> <span class="n">make_params_combinations</span><span class="p">(</span><span class="n">nb_iters</span><span class="p">,</span> <span class="n">nb_iters_same_topo_graph</span><span class="p">,</span> <span class="n">MEASURE_PARAMS</span><span class="p">,</span> <span class="n">measure_params</span><span class="p">)</span>
    

    <span class="n">sim_params</span> <span class="o">=</span> <span class="n">get_sim_params</span><span class="p">()</span>
    
    <span class="n">net_params</span> <span class="o">=</span> <span class="n">NetworkParams</span><span class="p">(</span><span class="n">dummypol_deltar</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
                               <span class="n">rtprop_policy_max_routes</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                               <span class="n">rtprop_policy_p_reaccept</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">,</span>
                               <span class="n">rtprop_policy_p_replace</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                               <span class="n">batching_t_interval</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">1000</span><span class="p">,</span>
                               <span class="n">batching_nmin</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                               <span class="n">batching_f</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
                               <span class="n">dummypol_fdum</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">generic_measure</span><span class="p">(</span><span class="n">MEASURE_TITLE</span><span class="p">,</span> <span class="n">save_results_to</span><span class="p">,</span> 
                           <span class="n">net_params_combinations</span><span class="p">,</span> 
                           <span class="n">metrics_computer_callback</span><span class="o">=</span><span class="n">compute_metrics_one_network_run</span><span class="p">,</span>
                           <span class="n">sim_params</span><span class="o">=</span><span class="n">sim_params</span><span class="p">,</span>
                           <span class="n">net_params</span><span class="o">=</span><span class="n">net_params</span><span class="p">,</span>
                           <span class="n">save_network_states</span><span class="o">=</span><span class="n">save_network_states</span><span class="p">,</span>
                           <span class="n">restrict_to_params</span><span class="o">=</span><span class="n">restrict_to_params</span><span class="p">,</span>
                           <span class="n">overwrite_existing</span><span class="o">=</span><span class="n">overwrite_existing</span><span class="p">,</span>
                           <span class="n">force_recomputation</span><span class="o">=</span><span class="n">force_recomputation</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_sim_params</span><span class="p">():</span>
    <span class="n">sim_params</span> <span class="o">=</span> <span class="n">SimulationParams</span><span class="p">()</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">logging_level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span>  <span class="c1"># Display only Warnings or errors</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">print_nodes_tables</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># In general, no one will be there to see the stdout or graphs, so don&#39;t draw them</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">draw_topology_graph</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">draw_routes</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">time_of_simulation</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Go until the end of the simulation</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">automatic_oriented_comm_phase</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># We only measure topo diss, so no oriented communications are neede</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">oriented_communication_sessions</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># Each node sends 1 message to 10 different receivers</span>
    
    <span class="c1"># Put all the logging to False by default</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_ocom_latency</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_end_topo_diss</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_end_ocom_phase</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_and_store_all_real_msgs</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_dummy_link_msgs</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_real_link_msgs</span> <span class="o">=</span> <span class="kc">False</span>     
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_real_e2e_msgs</span> <span class="o">=</span> <span class="kc">False</span>           
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_histogram_real_msgs_per_round</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_traffic_rates_equilibrium</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_real_msgs_waiting_time</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_histogram_real_msgs_waiting_time</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_e2e_dummies</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_frequency_batch_intervention</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_route_props</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_sent_link_msgs_per_round</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_rt_props_latency</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">sim_params</span><span class="o">.</span><span class="n">log_ocom_routes</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">return</span> <span class="n">sim_params</span>

<span class="k">def</span> <span class="nf">compute_metrics_one_network_run</span><span class="p">(</span><span class="n">aggregated_metrics</span><span class="p">,</span> <span class="n">net_mngr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Callback function for this measure module.</span>
<span class="sd">    </span>
<span class="sd">    Computes the statistics on the network state at the end of a run, and</span>
<span class="sd">    aggregates the statistics over several network runs.</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">        aggregated_metrics</span>
<span class="sd">        net_mngr(:obj:`apart.core.networtk.NetworkManager`): the network </span>
<span class="sd">            manager, containing in particular the network state after the run. </span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        dict, dict: The resulting statistics</span>

<span class="sd">        The first dict contains the *aggregated statistics. That is, d[k] = v,</span>
<span class="sd">        where k is the metric measure_name, and v is *aggregated* metric value over all</span>
<span class="sd">        iterations (of a particular parameters combination) that happened so far</span>

<span class="sd">        The second dict contains the statistics for the one network unr. That</span>
<span class="sd">        is, dict: d[k] = v, where k is the metric measure_name, and v is the metric</span>
<span class="sd">        value. This value can be an int, a float, a dict, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    


    <span class="k">if</span> <span class="n">aggregated_metrics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is the first iteration of a parameters combination. </span>
        <span class="n">aggregated_metrics</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">aggregated_metrics</span><span class="p">[</span><span class="n">_HIST_SIMPLE_ROUTE_LENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">aggregated_metrics</span><span class="p">[</span><span class="n">_TOPOLOGY_GRAPH</span><span class="p">]</span> <span class="o">=</span> <span class="n">net_mngr</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">topology_graph</span>

    
    <span class="n">stats_helper</span> <span class="o">=</span> <span class="n">AdvancedNetworkStatsHelper</span><span class="p">(</span><span class="n">net_mngr</span><span class="p">)</span>
    <span class="n">this_iteration_metrics</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># This function call may take a long time to return</span>
    <span class="n">routes</span> <span class="o">=</span> <span class="n">stats_helper</span><span class="o">.</span><span class="n">complete_routes_descriptions</span>
     
    
    <span class="c1"># Update the histogram of routes lengths (for this topology graph, which</span>
    <span class="c1"># should be the same across all iterations</span>
    <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">routes</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
        <span class="n">aggregated_metrics</span><span class="p">[</span><span class="n">_HIST_SIMPLE_ROUTE_LENGTH</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    
    
    <span class="c1"># Store the corruption states and the full ocom routes for this iteration</span>
    <span class="n">this_iteration_metrics</span><span class="p">[</span><span class="n">_CORRUPTION_STATES</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">is_corrupted</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">net_mngr</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">this_iteration_metrics</span><span class="p">[</span><span class="n">_FULL_OCOM_ROUTES</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ocom_route</span> <span class="ow">in</span> <span class="n">net_mngr</span><span class="o">.</span><span class="n">net_stats</span><span class="o">.</span><span class="n">ocom_routes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">end_sender</span> <span class="o">=</span> <span class="n">ocom_route</span><span class="p">[</span><span class="s1">&#39;end_sender&#39;</span><span class="p">]</span>
        <span class="n">end_rcvr</span> <span class="o">=</span> <span class="n">ocom_route</span><span class="p">[</span><span class="s1">&#39;end_rcvr&#39;</span><span class="p">]</span>
        <span class="n">helper</span> <span class="o">=</span> <span class="n">ocom_route</span><span class="p">[</span><span class="s1">&#39;helper&#39;</span><span class="p">]</span>
        <span class="n">end_sender_first_hop_node</span> <span class="o">=</span> <span class="n">ocom_route</span><span class="p">[</span><span class="s1">&#39;first_hop_end_sender&#39;</span><span class="p">][</span><span class="s1">&#39;node&#39;</span><span class="p">]</span>
        <span class="n">end_sender_first_hop_cid</span> <span class="o">=</span> <span class="n">ocom_route</span><span class="p">[</span><span class="s1">&#39;first_hop_end_sender&#39;</span><span class="p">][</span><span class="s1">&#39;cid&#39;</span><span class="p">]</span>
        <span class="n">helper_first_hop_node</span> <span class="o">=</span> <span class="n">ocom_route</span><span class="p">[</span><span class="s1">&#39;first_hop_helper&#39;</span><span class="p">][</span><span class="s1">&#39;node&#39;</span><span class="p">]</span>
        <span class="n">helper_first_hop_cid</span> <span class="o">=</span> <span class="n">ocom_route</span><span class="p">[</span><span class="s1">&#39;first_hop_helper&#39;</span><span class="p">][</span><span class="s1">&#39;cid&#39;</span><span class="p">]</span>
        
        <span class="c1"># Find he exact (full) ocom route</span>
        <span class="n">route_first_leg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">route</span> <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">routes</span><span class="p">[(</span><span class="n">end_sender</span><span class="p">,</span> <span class="n">helper</span><span class="p">)]</span> 
                                <span class="k">if</span> <span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">end_sender</span><span class="p">,</span> <span class="n">end_sender_first_hop_cid</span><span class="p">)</span> <span class="ow">and</span> <span class="n">route</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">end_sender_first_hop_node</span><span class="p">))</span>
 
        <span class="n">full_route</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">net_mngr</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">is_corrupted</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">route_first_leg</span><span class="p">]</span>
        <span class="n">full_route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">full_route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">full_route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;helper&#39;</span><span class="p">)</span>
         
        <span class="k">if</span> <span class="n">helper</span> <span class="o">!=</span> <span class="n">end_rcvr</span><span class="p">:</span>
            <span class="n">route_second_leg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">route</span> <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">routes</span><span class="p">[(</span><span class="n">helper</span><span class="p">,</span> <span class="n">end_rcvr</span><span class="p">)]</span> 
                                    <span class="k">if</span> <span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">helper</span><span class="p">,</span> <span class="n">helper_first_hop_cid</span><span class="p">)</span> <span class="ow">and</span> <span class="n">route</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">helper_first_hop_node</span><span class="p">))</span>
             
            <span class="n">full_route</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">net_mngr</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">is_corrupted</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">route_second_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        
        <span class="c1"># Alternatively, to be more compact, we could store: end_sender,</span>
        <span class="c1"># end_receiver, nb_hops_corrupted, last_corrupted_node_considered</span>
        <span class="n">this_iteration_metrics</span><span class="p">[</span><span class="n">_FULL_OCOM_ROUTES</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_route</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">aggregated_metrics</span><span class="p">,</span> <span class="n">this_iteration_metrics</span>




<span class="c1"># #################################</span>
<span class="c1"># Plotting functions ############## </span>
<span class="c1"># #################################</span>

<span class="c1"># The private module functions (those beginning with &quot;_&quot; below) are all there to</span>
<span class="c1"># help process results from simulations, and compute the receiver aonymity.</span>

<span class="k">def</span> <span class="nf">_gen_p_distribs_routes_lengths</span><span class="p">(</span><span class="n">hist_simple_route_length</span><span class="p">,</span> <span class="n">nb_nodes</span><span class="p">):</span>
    <span class="c1"># Transform the histogram into a probability distribution</span>
    <span class="n">normaliser</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">hist_simple_route_length</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">p_distrib_length_simple_route</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="n">normaliser</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">hist_simple_route_length</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
    <span class="n">max_hops_one_route</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p_distrib_length_simple_route</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
          
    <span class="c1"># Deduce the compound probability distribution on a full route (two legs)</span>
    <span class="n">max_hops_full_route</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">max_hops_one_route</span>
    <span class="n">p_distrib_first_leg</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">p_distrib_length_simple_route</span><span class="p">)</span>
    <span class="n">p_distrib_second_leg</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="n">p_distrib_second_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">nb_nodes</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="n">nb_nodes</span><span class="p">)</span>
    <span class="n">p_distrib_second_leg</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="n">nb_nodes</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_distrib_length_simple_route</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p_distrib_second_leg</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.000000001</span><span class="p">,</span> <span class="s2">&quot;Second leg p distrib is not a prob distrib: sum is </span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p_distrib_second_leg</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">p_distrib_second_leg</span><span class="p">)</span>
    <span class="n">p_distrib_full_route</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">range1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_hops_full_route</span><span class="p">):</span>
        <span class="n">p_distrib_full_route</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">range1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_hops_full_route</span><span class="p">):</span>
            <span class="n">p_distrib_full_route</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p_distrib_first_leg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">p_distrib_second_leg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">l2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p_distrib_full_route</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.00000001</span><span class="p">,</span> <span class="s2">&quot;Compound p distrib is not a prob distrib: sum is </span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p_distrib_full_route</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">p_distrib_full_route</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">p_distrib_full_route</span>

<span class="k">def</span> <span class="nf">_gen_p_distrib_receivers_adv_view</span><span class="p">(</span><span class="n">corruption_states</span><span class="p">,</span> <span class="n">topology_graph</span><span class="p">,</span> <span class="n">p_distrib_length_ocom_routes</span><span class="p">,</span> <span class="n">full_route</span><span class="p">,</span> <span class="n">first_honest_node_after_collusion</span><span class="p">,</span> <span class="n">nb_hops_corrupted</span><span class="p">,</span> <span class="n">max_remaining_hop_count_adv_view</span><span class="p">,</span> <span class="n">potential_receivers</span><span class="p">,</span> <span class="n">longest_shortest_path</span><span class="p">):</span>
    <span class="c1"># Deduce the probability distribution on remaining route length of the adversary          </span>
    <span class="n">p_distrib_remaining_hops_adv_view</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">normaliser</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">p_distrib_length_ocom_routes</span><span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="n">nb_hops_corrupted</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">range1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_remaining_hop_count_adv_view</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">range1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_remaining_hop_count_adv_view</span><span class="p">):</span>
        <span class="n">p_distrib_remaining_hops_adv_view</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_distrib_length_ocom_routes</span><span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="n">nb_hops_corrupted</span><span class="p">]</span><span class="o">/</span><span class="n">normaliser</span>
        
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p_distrib_remaining_hops_adv_view</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.00000001</span><span class="p">,</span> <span class="s2">&quot;Adversary&#39;s distrib on hop count is not a prob distrib: sum is </span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p_distrib_remaining_hops_adv_view</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">p_distrib_remaining_hops_adv_view</span><span class="p">)</span>


    <span class="c1"># Compute the longest shortest path in the network</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_remaining_hop_count_adv_view</span><span class="p">,</span> <span class="n">longest_shortest_path</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    
    <span class="n">receivers_at_n_hops</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    
    <span class="c1"># The only receiver possible at 0 hop is the node next to the last corrupted</span>
    <span class="c1"># node</span>
    <span class="n">receivers_at_n_hops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">first_honest_node_after_collusion</span><span class="p">)</span>
        
    <span class="c1"># For all hops longer than the longest shortest path, we can be sure that</span>
    <span class="c1"># the anonymity set is maximal</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">range1</span><span class="p">(</span><span class="n">longest_shortest_path</span><span class="p">,</span> <span class="n">max_remaining_hop_count_adv_view</span><span class="p">):</span>
        <span class="n">receivers_at_n_hops</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">potential_receivers</span><span class="p">)</span>
    
    <span class="c1"># To exhaustively test all other hops, use the functions provided by</span>
    <span class="c1"># networkx, that forces us to iterate over receivers (rather than route</span>
    <span class="c1"># lengths)</span>
    <span class="k">for</span> <span class="n">receiver</span> <span class="ow">in</span> <span class="n">potential_receivers</span><span class="p">:</span>
        <span class="n">all_paths</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">(</span><span class="n">topology_graph</span><span class="p">,</span> 
                                        <span class="n">source</span><span class="o">=</span><span class="n">first_honest_node_after_collusion</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">receiver</span><span class="p">,</span> 
                                        <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">all_paths</span><span class="p">:</span>
            <span class="n">receivers_at_n_hops</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">receiver</span><span class="p">)</span>
    
    <span class="c1"># Normalise the distrib on route lengths, if there is a number of hop at</span>
    <span class="c1"># which no receiver is possible</span>
    <span class="n">normaliser</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_distrib_remaining_hops_adv_view</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">receivers_at_n_hops</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">p_distrib_remaining_hops_adv_view</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="o">/</span><span class="n">normaliser</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_distrib_remaining_hops_adv_view</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    

    <span class="c1"># Finally, compute the prob distrib</span>
    <span class="n">p_distrib_receivers_adversary_view</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">range1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_remaining_hop_count_adv_view</span><span class="p">):</span>
        <span class="n">p_this_length</span> <span class="o">=</span> <span class="n">p_distrib_remaining_hops_adv_view</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">receiver</span> <span class="ow">in</span> <span class="n">receivers_at_n_hops</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
            <span class="n">p_distrib_receivers_adversary_view</span><span class="p">[</span><span class="n">receiver</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p_this_length</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">receivers_at_n_hops</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
    
    
    <span class="c1"># Again, a normalisation : because some hops may have no possible</span>
    <span class="c1"># honest receiver (i.e. all receiver at e;g. 1 hop are corrupted)</span>
<span class="c1">#     normaliser = sum(p_distrib_receivers_adversary_view.values())</span>
<span class="c1">#     p_distrib_receivers_adversary_view = dict((r, p/normaliser) for r, p in p_distrib_receivers_adversary_view.items())</span>
      
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p_distrib_receivers_adversary_view</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.00000001</span><span class="p">,</span> <span class="s2">&quot;Adversary&#39;s distrib on receiver is not a prob distrib: sum is </span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p_distrib_receivers_adversary_view</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">p_distrib_receivers_adversary_view</span><span class="p">)</span>
    
    
    <span class="k">return</span> <span class="n">p_distrib_receivers_adversary_view</span><span class="p">,</span> <span class="n">p_distrib_remaining_hops_adv_view</span><span class="p">,</span> <span class="n">receivers_at_n_hops</span>



<span class="k">def</span> <span class="nf">_simple_collusion_get_collusion_info</span><span class="p">(</span><span class="n">full_route</span><span class="p">):</span>
    <span class="c1"># Simple collusion (as opposed to end-to-end collusion) : finds the largest</span>
    <span class="c1"># collusion of consecutive corrutped nodes on the route</span>
    
    <span class="n">collusions</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">current_collusion_start_node</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">full_route</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">current_collusion_start_node</span><span class="p">:</span>
                <span class="n">collusions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;nb_hops&#39;</span><span class="p">:</span> <span class="n">collusions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;nb_hops&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_collusion_start_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">collusions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;first&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;nb_hops&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_collusion_start_node</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">largest_collusion</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">collusions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;nb_hops&#39;</span><span class="p">])</span>
    
    <span class="k">assert</span> <span class="n">largest_collusion</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_route</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">first_honest_node_after_collusion</span> <span class="o">=</span> <span class="n">full_route</span><span class="p">[</span><span class="n">largest_collusion</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Deduce the non potential receiver, i.e. there can be only one, in all cases</span>
    <span class="n">non_potential_receivers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">second_leg_start</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">full_route</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_route</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">full_route</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;helper&#39;</span><span class="p">)</span>
    <span class="n">non_potential_receiver_index</span> <span class="o">=</span> <span class="n">largest_collusion</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">non_potential_receiver_index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">non_potential_receiver_index</span> <span class="o">&gt;=</span> <span class="n">second_leg_start</span><span class="p">:</span>
        <span class="n">non_potential_receivers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">full_route</span><span class="p">[</span><span class="n">non_potential_receiver_index</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>    
    
    
    
     
    <span class="c1"># Find the maximum number of remaining hops, according to the adversary&#39;s view</span>
    <span class="n">nb_hops_corrupted</span> <span class="o">=</span> <span class="p">(</span><span class="n">largest_collusion</span><span class="p">[</span><span class="s1">&#39;nb_hops&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">largest_collusion</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nb_hops_corrupted</span> <span class="o">-=</span> <span class="mi">1</span> 
     
<span class="c1">#     last_corrupted_node_considered = largest_collusion[2]</span>
<span class="c1">#     first_honest_node_after_collusion = full_route_nodes_only[full_route_nodes_only.index(last_corrupted_node_considered)+1]</span>
    
    <span class="k">return</span> <span class="n">nb_hops_corrupted</span><span class="p">,</span> <span class="n">first_honest_node_after_collusion</span><span class="p">,</span> <span class="n">non_potential_receivers</span>

<span class="k">def</span> <span class="nf">_end_to_end_collusion_get_collusion_info</span><span class="p">(</span><span class="n">full_route</span><span class="p">):</span>
    <span class="c1"># End-to-end collusion (as opposed to simple collusions): take the first and</span>
    <span class="c1"># last corrupted nodes on the route, and consider all the portion of route</span>
    <span class="c1"># in-between as being corrupted</span>
    
    <span class="n">full_route_nodes_only</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">full_route</span><span class="p">]</span>
    
    <span class="c1"># Find the first and last corrupted node on the route</span>
    <span class="n">first_honest_node_after_collusion</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">end_corrupted_nodes_on_route</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;first&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;nb_hops&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">full_route</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">end_corrupted_nodes_on_route</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end_corrupted_nodes_on_route</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">end_corrupted_nodes_on_route</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">end_corrupted_nodes_on_route</span><span class="p">[</span><span class="s1">&#39;nb_hops&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_route_nodes_only</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">full_route_nodes_only</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">end_corrupted_nodes_on_route</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_route</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">first_honest_node_after_collusion</span> <span class="o">=</span> <span class="n">full_route</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> 
    
    <span class="c1"># Deduce the impossible receiver: the ones that share an edge with a node in</span>
    <span class="c1"># the collusion (except the last one) on the *second leg* of the route</span>
    <span class="n">non_potential_receivers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">second_leg_start</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">full_route</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_route</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">full_route</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;helper&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">second_leg_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_route</span><span class="p">)):</span> 
        <span class="n">n</span> <span class="o">=</span> <span class="n">full_route</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">full_route</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_route</span><span class="p">)</span> <span class="ow">and</span> <span class="n">full_route</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">full_route</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_route</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">non_potential_receivers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">non_potential_receivers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">first_honest_node_after_collusion</span><span class="p">)</span> <span class="c1"># Just to be sure           </span>
                      
    <span class="c1"># Compute the maximum remaining number of hops</span>
    <span class="n">nb_hops_corrupted</span> <span class="o">=</span> <span class="n">end_corrupted_nodes_on_route</span><span class="p">[</span><span class="s1">&#39;nb_hops&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">end_corrupted_nodes_on_route</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">full_route</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">nb_hops_corrupted</span> <span class="o">-=</span> <span class="mi">1</span> 
    
<span class="c1">#     last_corrupted_node_considered = end_corrupted_nodes_on_route[&#39;last&#39;]</span>
    
    <span class="k">return</span> <span class="n">nb_hops_corrupted</span><span class="p">,</span> <span class="n">first_honest_node_after_collusion</span><span class="p">,</span> <span class="n">non_potential_receivers</span>

<span class="k">def</span> <span class="nf">_compute_receiver_anonymity</span><span class="p">(</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="n">corruption_ratio</span><span class="p">,</span> <span class="n">topo_graph</span><span class="p">,</span> <span class="n">hist_simple_route_length</span><span class="p">,</span> <span class="n">iteration_results</span><span class="p">,</span> <span class="n">use_simple_collusion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Get the prob distrib on routes length, several network runs taken into account</span>
    <span class="n">p_distrib_length_ocom_routes</span> <span class="o">=</span> <span class="n">_gen_p_distribs_routes_lengths</span><span class="p">(</span><span class="n">hist_simple_route_length</span><span class="p">,</span> <span class="n">nb_nodes</span><span class="p">)</span>
    <span class="n">max_hops_full_route</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_distrib_length_ocom_routes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    
    
    <span class="n">all_shortest_paths_lengths</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">topo_graph</span><span class="p">)</span>
    <span class="n">longest_shortest_path</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">all_shortest_paths_lengths</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>

    <span class="c1"># Iterate over each network run (i.e. over each iteration) that use the</span>
    <span class="c1"># same topo graph. Create histograms, that merge values independently</span>
    <span class="c1"># from their network run</span>
    <span class="n">hist_normalised_entropies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hist_normalised_min_entropies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hist_most_likely_rcvr_prob</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nb_good_guesses</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nb_routes_total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">chances_of_good_guess_alternative</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">maximal_anonymity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">iteration_result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iteration_results</span><span class="p">):</span>
        <span class="c1"># Change of plans : we do not use the corruption state of the network,</span>
        <span class="c1"># but generate a new corruption state here. That allows the re-use of </span>
        <span class="c1"># the same simulation results, and has no impact on the simulation </span>
        <span class="c1"># itself (results stay fully valid, because corruption state have </span>
        <span class="c1"># no impact on node behavior)</span>
        <span class="n">base_full_ocom_routes</span> <span class="o">=</span> <span class="n">iteration_result</span><span class="p">[</span><span class="n">_FULL_OCOM_ROUTES</span><span class="p">]</span>
<span class="c1">#         base_corruption_states = iteration_result[_CORRUPTION_STATES]</span>
        
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">corrupted_nodes_indexes</span> <span class="o">=</span> <span class="n">Network</span><span class="o">.</span><span class="n">gen_corruption_states</span><span class="p">(</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="n">corruption_ratio</span><span class="p">,</span> <span class="n">topo_graph</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="n">SimulationException</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">corruption_states</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">corrupted_nodes_indexes</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_nodes</span><span class="p">))</span>
        <span class="n">full_ocom_routes</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corruption_states</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;helper&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;helper&#39;</span> <span class="k">else</span>  <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corruption_states</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">one_full_ocom_route</span><span class="p">]</span> <span class="k">for</span> <span class="n">one_full_ocom_route</span> <span class="ow">in</span> <span class="n">base_full_ocom_routes</span><span class="p">]</span>
        
    
        <span class="n">total_honest_receivers</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="ow">not</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corruption_states</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="c1">#         maximal_entropy = math.log(total_honest_receivers, 2)</span>

        <span class="c1"># Iterate over each ocom route, and fill up the histograms</span>
        <span class="k">for</span> <span class="n">full_route</span> <span class="ow">in</span> <span class="n">full_ocom_routes</span><span class="p">:</span>
            <span class="c1"># TODO temporary : if receiver corrupted, abort</span>
            <span class="k">if</span> <span class="n">full_route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
              
            <span class="c1"># If the route has no corrupted nodes, the entropy is maximal !</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">((</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">full_route</span><span class="p">)):</span>
                <span class="c1"># If there are no corrupted node on the route, it is the best case scenario !</span>
                <span class="n">hist_normalised_entropies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="n">hist_most_likely_rcvr_prob</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">total_honest_receivers</span><span class="p">)</span>
                <span class="n">nb_good_guesses</span> <span class="o">+=</span> <span class="mi">0</span>
                <span class="n">nb_routes_total</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">chances_of_good_guess_alternative</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">maximal_anonymity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">continue</span>
              
              
            <span class="k">if</span> <span class="n">use_simple_collusion</span><span class="p">:</span>
                <span class="n">nb_hops_corrupted</span><span class="p">,</span> <span class="n">first_honest_node_after_collusion</span><span class="p">,</span> <span class="n">non_potential_receivers</span> <span class="o">=</span> <span class="n">_simple_collusion_get_collusion_info</span><span class="p">(</span><span class="n">full_route</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nb_hops_corrupted</span><span class="p">,</span> <span class="n">first_honest_node_after_collusion</span><span class="p">,</span> <span class="n">non_potential_receivers</span> <span class="o">=</span> <span class="n">_end_to_end_collusion_get_collusion_info</span><span class="p">(</span><span class="n">full_route</span><span class="p">)</span>
            
            <span class="n">max_remaining_hop_count_adv_view</span> <span class="o">=</span> <span class="n">max_hops_full_route</span><span class="o">-</span><span class="n">nb_hops_corrupted</span>
            <span class="n">potential_receivers</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corruption_states</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">non_potential_receivers</span><span class="p">]</span>
            
              
            <span class="n">p_distrib_receivers_adv_view</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_gen_p_distrib_receivers_adv_view</span><span class="p">(</span><span class="n">corruption_states</span><span class="p">,</span> <span class="n">topo_graph</span><span class="p">,</span>
                                                                             <span class="n">p_distrib_length_ocom_routes</span><span class="p">,</span> 
                                                                             <span class="n">full_route</span><span class="p">,</span> <span class="n">first_honest_node_after_collusion</span><span class="p">,</span> 
                                                                             <span class="n">nb_hops_corrupted</span><span class="p">,</span> <span class="n">max_remaining_hop_count_adv_view</span><span class="p">,</span>
                                                                             <span class="n">potential_receivers</span><span class="p">,</span> <span class="n">longest_shortest_path</span><span class="p">)</span>
            
            
            
            <span class="n">diff</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">p_distrib_receivers_adv_view</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">potential_receivers</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">diff</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error : potential receivers and p distrib do not feature the same receivers&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Potentials : &quot;</span><span class="p">,</span> <span class="n">potential_receivers</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;p distrib : &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">p_distrib_receivers_adv_view</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">full_route</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>
            
            <span class="c1"># Deduce entropy, maximal prob, and most likely receiver</span>
            <span class="n">entropy</span> <span class="o">=</span> <span class="o">-</span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">total</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">total</span><span class="o">+</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">p_distrib_receivers_adv_view</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">most_likely_receiver_prob</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p_distrib_receivers_adv_view</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">min_entropy</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">most_likely_receiver_prob</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">potential_receivers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">normalised_entropy</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">normalised_min_entropy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_entropy</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">total_honest_receivers</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">normalised_entropy</span> <span class="o">=</span> <span class="n">entropy</span><span class="o">/</span><span class="n">max_entropy</span>
                <span class="n">normalised_min_entropy</span> <span class="o">=</span> <span class="n">min_entropy</span><span class="o">/</span><span class="n">max_entropy</span>
            
            
            
            <span class="n">most_likely_receivers</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_distrib_receivers_adv_view</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">most_likely_receiver_prob</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.0000001</span><span class="p">]</span> 
<span class="c1">#             </span>
            <span class="n">hist_normalised_entropies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalised_entropy</span><span class="p">)</span>
            <span class="n">hist_normalised_min_entropies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalised_min_entropy</span><span class="p">)</span>
            <span class="n">hist_most_likely_rcvr_prob</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">most_likely_receiver_prob</span><span class="p">)</span>
            <span class="n">good_guess</span> <span class="o">=</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">most_likely_receivers</span><span class="p">)</span> <span class="o">==</span> <span class="n">full_route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nb_good_guesses</span> <span class="o">+=</span> <span class="n">good_guess</span>
            <span class="n">nb_routes_total</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">full_route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">most_likely_receivers</span><span class="p">:</span>
                <span class="n">chances_of_good_guess_alternative</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chances_of_good_guess_alternative</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">most_likely_receivers</span><span class="p">))</span>
            <span class="n">maximal_anonymity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">total_honest_receivers</span><span class="p">)</span>
            
            <span class="k">assert</span> <span class="n">normalised_entropy</span> <span class="o">&lt;</span> <span class="mf">1.0</span>
            <span class="k">assert</span> <span class="n">most_likely_receiver_prob</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">potential_receivers</span><span class="p">))</span><span class="o">-</span><span class="mf">0.00000001</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;max prob = </span><span class="si">{}</span><span class="s2">, optimal prob = </span><span class="si">{}</span><span class="s2">, </span><span class="se">\n</span><span class="s2">&quot;</span>
                                                                                          <span class="s2">&quot;maxprob*len(potentials) = </span><span class="si">{}</span><span class="s2">, len(potentials) = </span><span class="si">{}</span><span class="s2">, len(prodistrib) = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                                                          <span class="s2">&quot;difference is : </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                                                          <span class="s2">&quot;full route is </span><span class="si">{}</span><span class="s2"> and potentials are </span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">most_likely_receiver_prob</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">potential_receivers</span><span class="p">),</span> 
                                                                                                                                              <span class="n">most_likely_receiver_prob</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">potential_receivers</span><span class="p">),</span>
                                                                                                                                              <span class="nb">len</span><span class="p">(</span><span class="n">potential_receivers</span><span class="p">),</span>
                                                                                                                                              <span class="nb">len</span><span class="p">(</span><span class="n">p_distrib_receivers_adv_view</span><span class="p">),</span>
                                                                                                                                              <span class="nb">set</span><span class="p">(</span><span class="n">potential_receivers</span><span class="p">)</span> <span class="o">^</span> <span class="nb">set</span><span class="p">(</span><span class="n">p_distrib_receivers_adv_view</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                                                                                                                              <span class="n">full_route</span><span class="p">,</span>
                                                                                                                                              <span class="n">potential_receivers</span><span class="p">,</span>
                                                                                                                                             <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_distrib_receivers_adv_view</span><span class="o">.</span><span class="n">items</span><span class="p">()])))</span>
            
            
            
            
        
    <span class="n">frequence_good_guesses</span> <span class="o">=</span> <span class="n">nb_good_guesses</span><span class="o">/</span><span class="n">nb_routes_total</span>
    <span class="k">return</span> <span class="n">hist_normalised_entropies</span><span class="p">,</span> <span class="n">hist_normalised_min_entropies</span><span class="p">,</span> <span class="n">frequence_good_guesses</span><span class="p">,</span> <span class="n">chances_of_good_guess_alternative</span><span class="p">,</span> <span class="n">maximal_anonymity</span>

            

<span class="k">def</span> <span class="nf">plot_RECEIVER_ANONYMITY_vs_theoretical</span><span class="p">(</span><span class="n">experiments_results</span><span class="p">,</span> <span class="n">restrict_to_other_params</span><span class="o">=</span><span class="p">{},</span> <span class="n">save_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_simple_collusion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">results_augmentation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_saved_poltting_results</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plots the receiver anonymity, along with the theoretical bound on receiver anonymity obtained from the formal proofs of the protocol&quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">save_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">save_to</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_to</span><span class="p">,</span> <span class="s1">&#39;receiver_anonymity/&#39;</span><span class="p">)</span>
    <span class="n">x_param</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;corruption_ratio&#39;</span><span class="p">,</span> <span class="s1">&#39;corruption ratio&#39;</span><span class="p">)</span>
    <span class="n">y_stat</span> <span class="o">=</span> <span class="p">(</span><span class="n">_RECEIVER_ANONYMITY</span><span class="p">,</span> <span class="s1">&#39;prob. of breaking RA&#39;</span><span class="p">,</span> <span class="s1">&#39;receiver_anonymity&#39;</span><span class="p">)</span>
    
    
    <span class="n">x_param</span><span class="p">,</span> <span class="n">y_stat</span><span class="p">,</span> <span class="n">restrict_to_other_params</span> <span class="o">=</span> <span class="n">process_plot_function_inputs</span><span class="p">(</span><span class="n">x_param</span><span class="p">,</span> <span class="n">y_stat</span><span class="p">,</span> <span class="n">restrict_to_other_params</span><span class="p">)</span>
    <span class="n">x_param</span><span class="p">,</span> <span class="n">x_param_label</span><span class="p">,</span> <span class="n">x_param_file_name</span> <span class="o">=</span> <span class="n">x_param</span>
    <span class="n">y_stat</span><span class="p">,</span> <span class="n">y_stat_label</span><span class="p">,</span> <span class="n">y_stat_file_name</span> <span class="o">=</span> <span class="n">y_stat</span>
    
    <span class="c1"># Load the param combinations for which the graphs were already computed.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_saved_poltting_results</span><span class="p">:</span>
        <span class="n">all_possible_graphs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">RunningStat</span><span class="p">))</span>
        <span class="n">all_possible_graphs_alternative</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;chances_good_guess&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="s1">&#39;maximal_anon&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)})</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">experiment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">experiments_results</span><span class="p">):</span>
            <span class="c1"># Keep the experiment results only if they fit into the asked other parameters</span>
            <span class="n">skip</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">v_list</span> <span class="ow">in</span> <span class="n">restrict_to_other_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span>  <span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;measure_params&#39;</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_list</span><span class="p">:</span>
                    <span class="n">skip</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>        
            <span class="k">if</span> <span class="n">skip</span><span class="p">:</span>
                <span class="k">continue</span>
            
            
            <span class="n">other_measure_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(((</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;measure_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">x_param</span> <span class="ow">and</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">MEASURE_PARAMS</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">MEASURE_PARAMS</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            
            <span class="n">other_measure_params</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;nb_iters&#39;</span><span class="p">,</span> <span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;measure_params&#39;</span><span class="p">][</span><span class="s1">&#39;nb_iters&#39;</span><span class="p">]))</span>
            <span class="n">collusion_type</span> <span class="o">=</span> <span class="s1">&#39;simple&#39;</span> <span class="k">if</span> <span class="n">use_simple_collusion</span> <span class="k">else</span> <span class="s1">&#39;endtoend&#39;</span>
            <span class="n">other_measure_params</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;collusion&#39;</span><span class="p">,</span> <span class="n">collusion_type</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;net_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rtprop_policy_max_hop_count</span><span class="p">:</span>
                <span class="n">lmax</span> <span class="o">=</span> <span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;net_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rtprop_policy_max_hop_count</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_shortest_paths_lengths</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">][</span><span class="s1">&#39;overall&#39;</span><span class="p">][</span><span class="n">_TOPOLOGY_GRAPH</span><span class="p">])</span>
                <span class="n">lmax</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">all_shortest_paths_lengths</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
            <span class="n">other_measure_params</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;rtprop_policy_max_hop_count&#39;</span><span class="p">,</span> <span class="n">lmax</span><span class="p">))</span>
            <span class="n">other_measure_params</span> <span class="o">=</span> <span class="n">make_hashable</span><span class="p">(</span><span class="n">other_measure_params</span><span class="p">)</span>
            
            
            <span class="k">if</span> <span class="n">results_augmentation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results_augmentation</span> <span class="o">=</span> <span class="p">[</span><span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;measure_params&#39;</span><span class="p">][</span><span class="n">x_param</span><span class="p">]]</span> 
            <span class="c1"># Then results_augmentation contains a list of corruption ratio values, that we &quot;simulate&quot; on the acquired network state</span>
            <span class="k">for</span> <span class="n">x_value</span> <span class="ow">in</span> <span class="n">results_augmentation</span><span class="p">:</span>
                <span class="n">x_value</span> <span class="o">=</span> <span class="n">make_hashable</span><span class="p">(</span><span class="n">x_value</span><span class="p">)</span>
                
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Treating network runs </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2"> with corruption ratio </span><span class="si">{}</span><span class="s2"> and params </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">experiments_results</span><span class="p">),</span> <span class="n">x_value</span><span class="p">,</span> <span class="n">other_measure_params</span><span class="p">))</span>
                
                <span class="c1"># Do the actual computation of sender/receiver privacy </span>
                <span class="n">aux</span> <span class="o">=</span> <span class="n">_compute_receiver_anonymity</span><span class="p">(</span><span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;measure_params&#39;</span><span class="p">][</span><span class="s1">&#39;nb_nodes&#39;</span><span class="p">],</span> 
                                                                           <span class="n">x_value</span><span class="p">,</span> 
                                                                           <span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">][</span><span class="s1">&#39;overall&#39;</span><span class="p">][</span><span class="n">_TOPOLOGY_GRAPH</span><span class="p">],</span> 
                                                                           <span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">][</span><span class="s1">&#39;overall&#39;</span><span class="p">][</span><span class="n">_HIST_SIMPLE_ROUTE_LENGTH</span><span class="p">],</span> 
                                                                           <span class="n">experiment</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">][</span><span class="s1">&#39;by_ite&#39;</span><span class="p">],</span>
                                                                           <span class="n">use_simple_collusion</span><span class="o">=</span><span class="n">use_simple_collusion</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">aux</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">frequence_good_guesses</span><span class="p">,</span> <span class="n">chances_of_good_guess_alternative</span><span class="p">,</span> <span class="n">maximal_anonymity</span> <span class="o">=</span> <span class="n">aux</span> 
                
                
                <span class="n">all_possible_graphs</span><span class="p">[</span><span class="n">other_measure_params</span><span class="p">][</span><span class="n">x_value</span><span class="p">]</span><span class="o">.</span><span class="n">push_value</span><span class="p">(</span><span class="n">frequence_good_guesses</span><span class="p">)</span>
                <span class="n">all_possible_graphs_alternative</span><span class="p">[</span><span class="n">other_measure_params</span><span class="p">][</span><span class="s1">&#39;chances_good_guess&#39;</span><span class="p">][</span><span class="n">x_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chances_of_good_guess_alternative</span><span class="p">)</span>
                <span class="n">all_possible_graphs_alternative</span><span class="p">[</span><span class="n">other_measure_params</span><span class="p">][</span><span class="s1">&#39;maximal_anon&#39;</span><span class="p">][</span><span class="n">x_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maximal_anonymity</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span>
                    
            
        
        <span class="c1"># Each graph must show a statistic (in y axis) according to a network</span>
        <span class="c1"># parameter (in x axis), where **only** this network parameter varies. Thus,</span>
        <span class="c1"># we make one graph per set of other network parameters</span>
        <span class="n">all_possible_graphs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">all_possible_graphs</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">all_possible_graphs_alternative</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">all_possible_graphs_alternative</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;/tmp&#39;</span><span class="p">,</span> <span class="s1">&#39;allpossiblegaphsvstheoretical.pickle&#39;</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">all_possible_graphs</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;/tmp/&#39;</span><span class="p">,</span> <span class="s1">&#39;allpossiblegaphsvstheoretical_alternative.pickle&#39;</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">all_possible_graphs_alternative</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">save_to</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">save_to</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mo">0o775</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_to</span><span class="p">,</span> <span class="s1">&#39;allpossiblegaphsvstheoretical.pickle&#39;</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">all_possible_graphs</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_to</span><span class="p">,</span> <span class="s1">&#39;allpossiblegaphsvstheoretical_alternative.pickle&#39;</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">all_possible_graphs_alternative</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_to</span><span class="p">,</span> <span class="s1">&#39;allpossiblegaphsvstheoretical.pickle&#39;</span><span class="p">),</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">all_possible_graphs</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_to</span><span class="p">,</span> <span class="s1">&#39;allpossiblegaphsvstheoretical_alternative.pickle&#39;</span><span class="p">),</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">all_possible_graphs_alternative</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        

    <span class="k">def</span> <span class="nf">theoretical_RA</span><span class="p">(</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> 
<span class="c1">#         print(&quot;For x = {} (c = {}), Return 1-{}/{}&quot;.format(x, math.floor(nb_nodes*x), comb(nb_nodes-lmax, math.floor(x*nb_nodes)), comb(nb_nodes, math.floor(x*nb_nodes))))</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">-</span><span class="n">comb</span><span class="p">(</span><span class="n">nb_nodes</span><span class="o">-</span><span class="n">lmax</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">comb</span><span class="p">(</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">other_measure_params</span><span class="p">,</span> <span class="n">graph_values</span> <span class="ow">in</span> <span class="n">all_possible_graphs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">x_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stdevs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sorted_zipped_data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">stdev</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph_values</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                                <span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
        <span class="n">x_values</span><span class="p">[</span><span class="s2">&quot;empirical2&quot;</span><span class="p">],</span> <span class="n">y_values</span><span class="p">[</span><span class="s2">&quot;empirical2&quot;</span><span class="p">],</span> <span class="n">stdevs</span><span class="p">[</span><span class="s2">&quot;empirical2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sorted_zipped_data</span><span class="p">))</span>
        <span class="n">stdevs</span><span class="p">[</span><span class="s2">&quot;empirical2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="n">sorted_zipped_data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(((</span><span class="n">k</span><span class="p">,</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]),</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">statistics</span><span class="o">.</span><span class="n">stdev</span><span class="p">([</span><span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]))</span> 
                                     <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_possible_graphs_alternative</span><span class="p">[</span><span class="n">other_measure_params</span><span class="p">][</span><span class="s1">&#39;chances_good_guess&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                                <span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
        <span class="n">x_values</span><span class="p">[</span><span class="s2">&quot;empirical&quot;</span><span class="p">],</span> <span class="n">y_values</span><span class="p">[</span><span class="s2">&quot;empirical&quot;</span><span class="p">],</span> <span class="n">stdevs</span><span class="p">[</span><span class="s2">&quot;empirical&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sorted_zipped_data</span><span class="p">))</span>
        <span class="n">stdevs</span><span class="p">[</span><span class="s2">&quot;empirical&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="n">sorted_zipped_data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(((</span><span class="n">k</span><span class="p">,</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]),</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">statistics</span><span class="o">.</span><span class="n">stdev</span><span class="p">([</span><span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]))</span> 
                                     <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_possible_graphs_alternative</span><span class="p">[</span><span class="n">other_measure_params</span><span class="p">][</span><span class="s1">&#39;maximal_anon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                                <span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
        <span class="n">x_values</span><span class="p">[</span><span class="s2">&quot;maximal_anon&quot;</span><span class="p">],</span> <span class="n">y_values</span><span class="p">[</span><span class="s2">&quot;maximal_anon&quot;</span><span class="p">],</span> <span class="n">stdevs</span><span class="p">[</span><span class="s2">&quot;maximal_anon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sorted_zipped_data</span><span class="p">))</span>
        <span class="n">stdevs</span><span class="p">[</span><span class="s2">&quot;maximal_anon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                
        <span class="n">other_measure_params_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">other_measure_params</span><span class="p">)</span>
        
        <span class="n">f</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">theoretical_RA</span><span class="p">,</span> <span class="n">other_measure_params_dict</span><span class="p">[</span><span class="s1">&#39;nb_nodes&#39;</span><span class="p">],</span> <span class="n">other_measure_params_dict</span><span class="p">[</span><span class="s1">&#39;rtprop_policy_max_hop_count&#39;</span><span class="p">])</span>
        <span class="n">x_values</span><span class="p">[</span><span class="s1">&#39;theoretical&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">/</span><span class="n">other_measure_params_dict</span><span class="p">[</span><span class="s1">&#39;nb_nodes&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">range1</span><span class="p">(</span><span class="n">other_measure_params_dict</span><span class="p">[</span><span class="s1">&#39;nb_nodes&#39;</span><span class="p">])]</span>
        <span class="n">y_values</span><span class="p">[</span><span class="s1">&#39;theoretical&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">range1</span><span class="p">(</span><span class="n">other_measure_params_dict</span><span class="p">[</span><span class="s1">&#39;nb_nodes&#39;</span><span class="p">]))]</span>
        <span class="n">stdevs</span><span class="p">[</span><span class="s1">&#39;theoretical&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;For params = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">other_measure_params</span><span class="p">))))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_values</span><span class="p">[</span><span class="s1">&#39;empirical&#39;</span><span class="p">],</span> <span class="n">y_values</span><span class="p">[</span><span class="s2">&quot;empirical&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> c = </span><span class="si">{}</span><span class="s2"> =&gt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            
        
        
        
        <span class="n">graph_description</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x_label&#39;</span><span class="p">:</span> <span class="n">x_param_label</span><span class="p">,</span> <span class="s1">&#39;y_label&#39;</span><span class="p">:</span> <span class="n">y_stat_label</span><span class="p">}</span>
        <span class="n">graph_description</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">other_measure_params</span><span class="p">))</span>
        
    
        <span class="c1"># Look for a fit</span>
        <span class="k">def</span> <span class="nf">linear_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">b</span>
        <span class="k">def</span> <span class="nf">power_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
        <span class="k">def</span> <span class="nf">sqrt_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">def</span> <span class="nf">inverse_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">a</span><span class="o">/</span><span class="n">x</span><span class="o">+</span><span class="n">b</span>
        <span class="k">def</span> <span class="nf">inverse_sigmoidal_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">k</span> <span class="o">+</span> <span class="n">y0</span>
        <span class="k">def</span> <span class="nf">inverse_generalised_sigmoidal_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">((</span>  <span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">a</span><span class="p">),</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span>   <span class="p">)</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>
                
        
<span class="c1">#         candidate_functions = [power_fit, inverse_generalised_sigmoidal_fit, inverse_sigmoidal_fit, sqrt_fit]</span>
<span class="c1">#         for j, candidate_function in enumerate(candidate_functions):</span>
<span class="c1">#             try:</span>
<span class="c1">#                 popt, _ = curve_fit(candidate_function, numpy.array(x_values[&#39;empirical&#39;]), numpy.array(y_values[&#39;empirical&#39;]), p0=candidate_function(None))</span>
<span class="c1">#                 print(&quot;{} : {}&quot;.format(candidate_function.__name__, popt))</span>
<span class="c1">#             except RuntimeError:</span>
<span class="c1">#                 continue</span>
<span class="c1">#             x_values[&#39;empirical_fit_{}&#39;.format(candidate_function.__name__)] = x_values[&#39;theoretical&#39;]</span>
<span class="c1">#             y_values[&#39;empirical_fit_{}&#39;.format(candidate_function.__name__)] = [candidate_function(x, *popt) for x in x_values[&#39;empirical_fit_{}&#39;.format(candidate_function.__name__)]]</span>
<span class="c1">#             stdevs[&#39;empirical_fit_{}&#39;.format(candidate_function.__name__)] = None</span>
<span class="c1">#         </span>
<span class="c1">#         several_curves = [&#39;theoretical&#39;, &#39;empirical&#39;] + ([s for s in x_values.keys() if s.startswith(&#39;empirical_fit&#39;)])</span>
<span class="c1">#         colors = [&#39;k&#39;, &#39;r&#39;] + ([&#39;g&#39;, &#39;b&#39;, &#39;y&#39;, &#39;m&#39;]*math.ceil(len(several_curves)-2))</span>
<span class="c1">#         markers = [&#39;&#39;, &#39;o&#39;] + ([&#39;&#39;]*(len(several_curves)-2))</span>
<span class="c1">#         linewidths = [1,0] + ([1]*(len(several_curves)-2))</span>
        
        <span class="n">several_curves</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;theoretical&#39;</span><span class="p">,</span> <span class="s1">&#39;empirical&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">x_values</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">several_curves</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">x_values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">y_values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">stdevs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> 
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span> 
        <span class="n">markers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">]</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        
        
        <span class="k">if</span> <span class="n">save_to</span><span class="p">:</span>
            <span class="n">graph_description</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_vs_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y_stat_file_name</span><span class="p">,</span> <span class="n">x_param_file_name</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">do_plot_simple_metric</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">stdevs</span><span class="p">,</span> <span class="n">graph_description</span><span class="p">,</span> 
                              <span class="n">several_curves</span><span class="o">=</span><span class="n">several_curves</span><span class="p">,</span> <span class="n">legend_placement</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">markers</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.01</span><span class="p">),</span>
                              <span class="n">save_to</span><span class="o">=</span><span class="n">save_to</span><span class="p">,</span> <span class="n">overwrite_existing</span><span class="o">=</span><span class="n">overwrite_existing</span><span class="p">)</span>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_DEFAULT_SAVING_FOLDER</span><span class="p">,</span> <span class="s1">&#39;measure_&#39;</span><span class="o">+</span><span class="n">MEASURE_TITLE</span><span class="p">)</span>
    
    <span class="n">do_measures</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">do_plot</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">if</span> <span class="n">do_measures</span><span class="p">:</span>
        <span class="n">measure_privacy</span><span class="p">(</span><span class="n">nb_nodes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                    <span class="n">nb_iters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="n">nb_iters_same_topo_graph</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="n">corruption_ratio</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span>
                                    <span class="n">save_results_to</span><span class="o">=</span><span class="n">folder</span><span class="p">,</span>
                                    <span class="n">overwrite_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">do_plot</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">load_measures_results</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">MEASURE_TITLE</span><span class="o">+</span><span class="s2">&quot;.pickle&quot;</span><span class="p">)</span>
        <span class="n">folder_graphs</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;graphs&quot;</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Plotting graphs...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span>  <span class="n">MEASURE_STATS</span><span class="p">:</span>
            <span class="n">plot_RECEIVER_ANONYMITY_vs_theoretical</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">save_to</span><span class="o">=</span><span class="n">folder_graphs</span><span class="p">,</span> <span class="n">overwrite_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_simple_collusion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    
    
</pre></div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="examples.measure_all.html" class="btn btn-neutral float-right" title="measure_all — Perform all three measures at once" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="examples.measure_route_prop.html" class="btn btn-neutral" title="measure_route_prop — Study the route proposal mechanism" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, University of Rennes 1 (author: Antoine Guellier).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>