# Author: Antoine Guellier
# Copyright (c) 2017 Université de Rennes 1
# License: CeCILL. The full license text is available at:
#  - http://www.cecill.info/licences/Licence_CeCILL_V2.1-fr.html


'''
This module defines the material to run network simulations.

It makes use of the elements defined in modules :mod:`~apart.core.network` and
:mod:`~apart.core.node`. This module defines :class:`~.SimulationParams`, the
class that regroups all simulation parameters, and the module function
:func:`.run_simulation` that effectively runs a simulation.
'''

from collections import defaultdict
import math
import random
import time 

from common.custom_logging import *
from apart.core.network import NetworkParams, NetworkManager


class SimulationParams(object):
    """Class grouping all the parameters of the simulation"""
    
    def __init__(self, **kwargs):
        """Accepts keyword arguments, corresponding to the simulation parameters"""
        
        self.logging_level = logging.INFO
        """The logging level of events in the network. 
        
        The ``INFO`` level basically gives information on the beginning and end
        of the two main phases of the simulation: topology dissemination and
        oriented communications. The ``DEBUG`` level gives information on the routes
        proposed (and accepted/refused), and on oriented communication messages
        sent. Further levels ``DEBUG2`` and ``DEBUG3`` give more detailed
        information are extremely verbose.
        """
        
        # Debug feature
        self.print_nodes_tables = False
        """Should the network manager display the node's tables at the end of the topology dissemination ?"""
        
        # Debug feature
        self.draw_topology_graph = False
        """Should the network topology graph be displayed at the beginning of the simulation"""
        
        # Debug feature: whether or not to draw routes at the end of the
        # simulation. This parameters is either None, or a list of 2-tuples
        # specifying as many  (from_node, to_node) as desired.
        self.draw_routes = None
        """Routes to draw at the end of the simulation"""
        
        # How long should the simulation last (in discrete time). If this value is
        # set to 0, the simulation stops when all nodes are idle
        self.time_of_simulation = 0
        """Force the stop of the simulation after a certain amount of simulated time"""
    
        # The simulation can stop after network topology dissemination, or try to
        # send payload messages. This parameter controls this.
        self.automatic_oriented_comm_phase = False
        """Whether the oriented communication phase should be triggered automatically by the network manager or not"""
        
        # The oriented communication sessions must be specified as a dict  dict
        # {sender1: {receiver1: [data1, ...}, {receiver2: [data1', ...]},
        # sender2: ...} If set to None, then random communication sessions will
        # be generated by nodes.
        self.oriented_communication_sessions = defaultdict(lambda: (12, 5))
        """The oriented communication sessions to run.
        
        The value of this parameter can be 
            * None: let node choose a random number of random communication partners
            * `dict[s] = list((r, list(data))` indicating that sender s must send the list of data to all receivers r in list
            * `dict[s] = list((r,n))` indicating that sender s must send the  n random pieces of data to all receivers r in list
            * `dict[s] = (n_r, n_data [, ndata_2])` indicating that sender s must choose n_r random receivers, 
              and send them n_data random messages each. If n_data2 is provided, the sender
              will choose a random number of messages to send in [n_data, n_data2], 
              different for each receiver 
        """
        
        
        # All the attributes that follow govern what statistics and metrics are
        #gathered on the network run
        
        # General efficiency metrics
        self.log_ocom_latency = False
        """Whether the latency (in rounds) of the oriented communication should be measured and logged or not"""
        
        self.log_end_topo_diss = True
        """Whether the round at which the topology dissemination terminates should be logged"""
        
        self.log_end_ocom_phase = True
        """Whether the round at which the oriented communication terminate should be logged"""

        
        # Messages
        self.log_and_store_all_real_msgs = False
        """Whether the(real) messages going through the network should be recorded or not. HEAVY MEMORY CONSUMPTION"""
        
        self.log_dummy_link_msgs = False
        """Whether the number of dummy messages sent by nodes at each rounds should be logged or not."""
        
        self.log_real_link_msgs = False 
        """Whether the number of real, end sent real, and ocom end sent real messages sent by nodes at each rounds should be logged or not"""
                
        self.log_real_e2e_msgs = False 
        """Whether the number of end sent real, and ocom end sent real messages sent by nodes at each rounds should be logged or not. Same for end received msgs"""
        
        self.log_histogram_real_msgs_per_round = False
        """Log the *exact discrete probability distribution* of the number of messages (real, and dummy separately) sent and received in a round by a node. High memory consumption""" 
        
        
        # Batching, traffic rates and dummies
        self.log_traffic_rates_equilibrium = False
        """Whether traffic rate equilibrium of nodes should be logged"""
        
        self.log_real_msgs_waiting_time = False
        """Whether the number of rounds that each real message passes waiting in the node's message pool should be recorded"""
        
        self.log_histogram_real_msgs_waiting_time = False
        """A more detailed logging than :attr:`.log_real_msgs_waiting_time`, that does not only give the mean and stdev, but the discrete probability distribution"""
        
        self.log_e2e_dummies = False
        """Whether the number of e2e dummies, and the frequency at which a node must "intervene" manually on a batch must be logged or not"""
        
        self.log_frequency_batch_intervention = False
        """Log the number of times that nodes had to manually modify the sampled batch: by removing real messages, by replacing a dummy with an e2e dummy, by adding an e2e dummy plus dummies, by adding many dummies (because no e2e are possible), or by resorting to the default dummy broadcast"""
        
        self.log_sent_link_msgs_per_round = False
        """Log a histogram (prob distrib) of the total number of link messages (real or dummies) that a node sends in a round"""
        
        
        # Routes, Routes proposals, and Route proposal policy
        self.log_route_props = False
        """Whether the number of route proposition (received, accepted and refused ones) should be counted, and their reason of acceptation/refusal"""
        
        self.log_rt_props_latency = False
        """Log the latency between the creation of a route proposal, and its finalization"""


        # Privacy: logging the ocom routes will allow to see how many and where
        # are the corrupted nodes on these routes, and the chance of the
        # adversary to de-anonymize senders and receivers
        self.log_ocom_routes = False
        """Log all the oriented communication routes used in the network"""
        
        self.update_params(**kwargs)
        
    def update_params(self, **kwargs):
        """Accepts keyword arguments, corresponding to the simulation parameters, and updates the instances'     attributes"""
        
        # Above are the default argument values. If kwargs is not empty,
        # override these values
        for attr_name, attr_value in kwargs.items():
            if attr_name in self.__dict__:
                setattr(self, attr_name, attr_value)
        
    def __str__(self):
        p_list = []
        for k, v in self.__dict__.items():
            if k == 'upgrade_params': continue
            p_list.append(k+"="+str(v))
        return '{}({})'.format(self.__class__.__name__, ", ".join(sorted(p_list)))



def run_simulation(sim_params=None, net_params=None, **kwargs):
    """Runs the network simulation, and returns the :obj:`~apart.core.network.NetworkManager` instance, describing the network in its final state.
    
    This function creates a :obj:`~apart.core.network.NetworkManager` instance,
    calls :meth:`~apart.core.network.NetworkManager.start` on it, and waits for
    the simulation to end. During the simulation, and depending on the loggin
    level parameter (:attr:`.SimulationParams.logging_level`), outputs various
    information on the events happening in the network.
    
    
    Unless they are specified in argument, simulation and network parameters are
    the default defined values in the classes :class:`.SimulationParams` and
    :class:`~apart.core.network.Networkparams`. There are two ways to provide
    custom arguments: by providing custom :class:`.SimulationParams` and
    :class:`~apart.core.network.Networkparams` instances, or by providing the
    parameters in keyword arguments. However, instances have precedence over
    keyword arguments. For instance, if a `sim_params` argument is provided,
    keyword arguments containing simulation parameters are ignored.
    
    Args:
        sim_params (:obj:`.SimulationParams`, default): specifies specific parameters 
            for the simulation, within a custom :obj:`.SimulationParams` instance.
            (Default: None)
        net_params (:obj:`~apart.core.network.Networkparams`): specifies specific 
            parameters for the network, within a custom :obj:`~apart.core.network.Networkparams` 
            instance. (Default: None)
        **kwargs (dict): specifies simulation or network parameters indistinctly. 
            If the `sim_params` parameter is `None`, the simulation parameters are generated as 
            `SimulationParams(**kwargs)`. Likewise for the `net_params` argument.
   
    
    Returns:
        :obj:`~apart.core.network.NetworkManager`: The network manager instance at the end of the network run. 
        Note that this object contains in particular a :attr:`~apart.core.network.NetworkManager.net_stats` 
        attribute, which contains valuable information on the simulated network run.
    """

    # If they were not passed in argument, get the parameters of the
    # simulation, and the sim_stats structures
    if sim_params is not None and isinstance(sim_params, SimulationParams):
        sim_params = sim_params
    else:
        sim_params = SimulationParams(**kwargs)
    
    if net_params is not None and isinstance(net_params, NetworkParams):
        net_params = net_params
    else:
        net_params = NetworkParams(**kwargs)
        

    # Init randomness (Note: randomness may have been intitialized before. Doesn't matter)
    random.seed(math.ceil(time.time() * 10000))

    # Configure the logging level
    logging.getLogger().setLevel(sim_params.logging_level)
   

    # Launch the simulation, which in a first phase will only disseminate the
    # network topology among the nodes
    start_time = time.time()
    logging.info("Starting network simulation.")
    
    
    # Instantiate the network
    net_mngr = NetworkManager(sim_params, net_params)
    net_mngr.start()
    
    end_time = time.time()
    logging.info('-' * 80)
    logging.info("End of simulation reached. Elapsed time: {} sec. End simulation time: {}".format(end_time - start_time, net_mngr.network.timestamp))
    
    # If as parameter of the simulation, it was asked to print some routes in the network, do it now
    if sim_params.draw_routes:
        net_mngr.network.draw_routes(*sim_params.draw_routes)

    return net_mngr


if __name__ == '__main__':
    run_simulation(nb_nodes=10, corruption_ratio=0.8, 
                   automatic_oriented_comm_phase=True, 
                   logging_level=logging.INFO, 
                   log_histogram_real_msgs_waiting_time=True)
            
        