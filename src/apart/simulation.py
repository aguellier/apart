# Author: Antoine Guellier
# Copyright (c) 2017 Université de Rennes 1
# License: CeCILL. The full license text is available at:
#  - http://www.cecill.info/licences/Licence_CeCILL_V2.1-fr.html


'''
This module defines the material to run network simulations.

It makes use of the elements defined in modules :mod:`~apart.core.network` and
:mod:`~apart.core.node`. This module defines :class:`~.SimulationParams`, the
class that regroups all simulation parameters, and the module function
:func:`.run_simulation` that effectively runs a simulation.
'''

from collections import defaultdict
import math
import random
import time 

from common.custom_logging import *
from apart.core.network import NetworkParams, NetworkManager


class SimulationParams(object):
    
    
    def __init__(self, **kwargs):
        """Class grouping all the parameters of the simulation
        
        When running a simulation, an instance of this class is used to specify the simulation parameters. 
        
        Args:
            **kwargs: keyword arguments corresponding to the simulation parameters
        
        
        .. note:: The value of (most of) the booleans in this class have an incidence on
                    the *attributes* that the instance of 
                    :obj:`~measures.network_statistics.NetworkStats` 
                    will have after the network run. For instance, if 
                    :attr:`.log_route_props` is `True`, then 
                    :obj:`~measures.network_statistics.NetworkStats` 
                    will have the attribute
                    :obj:`~measures.network_statistics.NetworkStats.nb_route_props_per_node`. 
                    Otherwise, accessing this attribute will trigger an 
                    :exc:`AttributeError`.
            
        """
        
        self.logging_level = logging.INFO
        """:mod:`logging` level: The logging level of events in the network. 
        
        Default: `logging.INFO`.
        
        The ``INFO`` level basically gives information on the beginning and end
        of the two main phases of the simulation: topology dissemination and
        oriented communications. The ``DEBUG`` level gives information on the routes
        proposed (and accepted/refused), and on oriented communication messages
        sent. Further levels ``DEBUG2`` and ``DEBUG3`` give more detailed
        information are extremely verbose.
        """
        
        # Debug feature
        self.print_nodes_tables = False
        """bool: Should the network manager display the node's tables at the end of the topology dissemination ?
        
        Default: `False`.
        """
        
        # Debug feature
        self.draw_topology_graph = False
        """bool: Should the network topology graph be displayed at the beginning of the simulation
        
        Default: `False`.
        """
        
        # Debug feature: whether or not to draw routes at the end of the
        # simulation. This parameters is either None, or a list of 2-tuples
        # specifying as many  (from_node, to_node) as desired.
        self.draw_routes = None
        """list of 2-tuples: Routes to draw at the end of the simulation.
        
        This parameter is specified under the form of a list of 2-tuples (n1,
        n2), asking to draw the route between node n1 and node n2.
        
        Default: `None`.
        """
        
        # How long should the simulation last (in discrete time). If this value is
        # set to 0, the simulation stops when all nodes are idle
        self.time_of_simulation = 0
        """int: Force the stop of the simulation after a certain amount of simulated time.
        
        Default: `0`, meaning that the simulation should stop *by itself*.
        
        The value of this attribute must represents a simulation time in the SimPy simulation. 
        """
    
        # The simulation can stop after network topology dissemination, or try to
        # send payload messages. This parameter controls this.
        self.automatic_oriented_comm_phase = False
        """bool: Whether the oriented communication phase should be triggered automatically by the network manager or not
        
        Default: `False`.
        """
        
        # The oriented communication sessions must be specified as a dict  dict
        # {sender1: {receiver1: [data1, ...}, {receiver2: [data1', ...]},
        # sender2: ...} If set to None, then random communication sessions will
        # be generated by nodes.
        self.oriented_communication_sessions = defaultdict(lambda: (12, 5))
        """dict: The oriented communication sessions to run.
        
        Default: `defaultdict(lambda: (12, 5))`.
        
        The value of this parameter can be 
            * None: let node choose a random number of random communication partners
            * `dict[s] = list((r, list(data))` indicating that sender s must send the list of data to all receivers r in list
            * `dict[s] = list((r,n))` indicating that sender s must send the  n random pieces of data to all receivers r in list
            * `dict[s] = (n_r, n_data [, ndata_2])` indicating that sender s must choose n_r random receivers, 
              and send them n_data random messages each. If n_data2 is provided, the sender
              will choose a random number of messages to send in [n_data, n_data2], 
              different for each receiver 
        """
        
        
        # All the attributes that follow govern what statistics and metrics are
        #gathered on the network run
        
        # General efficiency metrics
        self.log_ocom_latency = False
        """bool: Whether the latency (in rounds) of the oriented communication should be measured and logged or not
        
        Default: `False`.
        """
        
        self.log_end_topo_diss = True
        """bool: Whether the round at which the topology dissemination terminates should be logged
        
        Default: `True`.
        """
        
        self.log_end_ocom_phase = True
        """bool: Whether the round at which the oriented communication terminate should be logged
        
        Default: `True`.
        """

        
        # Messages
        self.log_and_store_all_real_msgs = False
        """bool: Whether the(real) messages going through the network should be recorded or not. 
        
        Default: `False`.
        
        .. warning:: Possibility of very heavy memory consumption.
        """
        
        self.log_dummy_link_msgs = False
        """bool: Whether the number of dummy messages sent by nodes at each rounds should be logged or not. 
        
        Default: `False`.
        """
        
        self.log_real_link_msgs = False 
        """bool: Whether the number of real, end sent real, and ocom end sent real messages sent by nodes at each rounds should be logged or not. 
        
        Default: `False`.
        """
                
        self.log_real_e2e_msgs = False 
        """bool: Whether the number of end sent real, and ocom end sent real messages sent by nodes at each rounds should be logged or not. Same for end received msgs. 
        
        Default: `False`.
        """
        
        self.log_histogram_real_msgs_per_round = False
        """bool: Log the *exact discrete probability distribution* of the number of messages (real, and dummy separately) sent and received in a round by a node. High memory consumption. 
        
        Default: `False`.
        """ 
        
        
        # Batching, traffic rates and dummies
        self.log_traffic_rates_equilibrium = False
        """bool: Whether traffic rate equilibrium of nodes should be logged. 
        
        Default: `False`.
        """
        
        self.log_real_msgs_waiting_time = False
        """bool: Whether the number of rounds that each real message passes waiting in the node's message pool should be recorded. 
        
        Default: `False`.
        """
        
        self.log_histogram_real_msgs_waiting_time = False
        """bool: A more detailed logging than :attr:`.log_real_msgs_waiting_time`, that does not only give the mean and stdev, but the discrete probability distribution. 
        
        Default: `False`.
        """
        
        self.log_e2e_dummies = False
        """bool: Whether the number of e2e dummies, and the frequency at which a node must "intervene" manually on a batch must be logged or not. 
        
        Default: `False`.
        """
        
        self.log_frequency_batch_intervention = False
        """bool: Log the number of times that nodes had to manually modify the sampled batch
                
        Default: `False`.
        
        The *batch interventions* are separated according to the nature of the
        intervention: removing real messages, replacing a dummy with an e2e
        dummy, adding an e2e dummy plus dummies, by adding many dummies
        (because no e2e are possible), or resorting to the default dummy
        broadcast.
        """
        
        self.log_sent_link_msgs_per_round = False
        """bool: Log a histogram (prob distrib) of the total number of link messages (real or dummies) that a node sends in a round. 
        
        Default: `False`.
        """
        
        
        # Routes, Routes proposals, and Route proposal policy
        self.log_route_props = False
        """bool: Whether the number of route proposition (received, accepted and refused ones) should be counted, and their reason of acceptation/refusal. 
        
        Default: `False`.
        """
        
        self.log_rt_props_latency = False
        """bool: Log the latency between the creation of a route proposal, and its finalization. 
        
        Default: `False`.
        """


        # Privacy: logging the ocom routes will allow to see how many and where
        # are the corrupted nodes on these routes, and the chance of the
        # adversary to de-anonymize senders and receivers
        self.log_ocom_routes = False
        """bool: Log all the oriented communication routes used in the network. 
        
        Default: `False`.
        """
        
        self.update_params(**kwargs)
        
    def update_params(self, **kwargs):
        """Accepts keyword arguments, corresponding to the simulation parameters, and updates the instances'  attributes
        
        Only keyword arguments that match a valid attribute of the class are
        taken into accounts. Others are simply ignored silently.
        """
        
        # Above are the default argument values. If kwargs is not empty,
        # override these values
        for attr_name, attr_value in kwargs.items():
            if attr_name in self.__dict__:
                setattr(self, attr_name, attr_value)
        
    def __str__(self):
        p_list = []
        for k, v in self.__dict__.items():
            if k == 'upgrade_params': continue
            p_list.append(k+"="+str(v))
        return '{}({})'.format(self.__class__.__name__, ", ".join(sorted(p_list)))



def run_simulation(sim_params=None, net_params=None, **kwargs):
    """Runs the network simulation, and returns the :obj:`~apart.core.network.NetworkManager` instance, describing the network in its final state.
    
    This function creates a :obj:`~apart.core.network.NetworkManager` instance,
    calls :meth:`~apart.core.network.NetworkManager.start` on it, and waits for
    the simulation to end. During the simulation, and depending on the loggin
    level parameter (:attr:`.SimulationParams.logging_level`), outputs various
    information on the events happening in the network.
    
    
    Unless they are specified in argument, simulation and network parameters are
    the default defined values in the classes :class:`.SimulationParams` and
    :class:`~apart.core.network.Networkparams`. There are two ways to provide
    custom arguments: by providing custom :class:`.SimulationParams` and
    :class:`~apart.core.network.Networkparams` instances, or by providing the
    parameters in keyword arguments. However, instances have precedence over
    keyword arguments. For instance, if a `sim_params` argument is provided,
    keyword arguments containing simulation parameters are ignored.
    
    Args:
        sim_params (:obj:`.SimulationParams`, default): specifies specific parameters 
            for the simulation, within a custom :obj:`.SimulationParams` instance.
            (Default: None)
        net_params (:obj:`~apart.core.network.Networkparams`): specifies specific 
            parameters for the network, within a custom :obj:`~apart.core.network.Networkparams` 
            instance. (Default: None)
        **kwargs (dict): specifies simulation or network parameters indistinctly. 
            If the `sim_params` parameter is `None`, the simulation parameters are generated as 
            `SimulationParams(**kwargs)`. Likewise for the `net_params` argument.
   
    
    Returns:
        :obj:`~apart.core.network.NetworkManager`: The network manager instance at the end of the network run. 
        Note that this object contains in particular a :attr:`~apart.core.network.NetworkManager.net_stats` 
        attribute, which contains valuable information on the simulated network run.
    """

    # If they were not passed in argument, get the parameters of the
    # simulation, and the sim_stats structures
    if sim_params is not None and isinstance(sim_params, SimulationParams):
        sim_params = sim_params
    else:
        sim_params = SimulationParams(**kwargs)
    
    if net_params is not None and isinstance(net_params, NetworkParams):
        net_params = net_params
    else:
        net_params = NetworkParams(**kwargs)
        

    # Init randomness (Note: randomness may have been intitialized before. Doesn't matter)
    random.seed(math.ceil(time.time() * 10000))

    # Configure the logging level
    logging.getLogger().setLevel(sim_params.logging_level)
   

    # Launch the simulation, which in a first phase will only disseminate the
    # network topology among the nodes
    start_time = time.time()
    logging.info("Starting network simulation.")
    
    
    # Instantiate the network
    net_mngr = NetworkManager(sim_params, net_params)
    net_mngr.start()
    
    end_time = time.time()
    logging.info('-' * 80)
    logging.info("End of simulation reached. Elapsed time: {} sec. End simulation time: {}".format(end_time - start_time, net_mngr.network.timestamp))
    
    # If as parameter of the simulation, it was asked to print some routes in the network, do it now
    if sim_params.draw_routes:
        net_mngr.network.draw_routes(*sim_params.draw_routes)

    return net_mngr


if __name__ == '__main__':
    run_simulation(nb_nodes=10, corruption_ratio=0.8, 
                   automatic_oriented_comm_phase=True, 
                   logging_level=logging.INFO, 
                   log_histogram_real_msgs_waiting_time=True)
            
        